---
创建时间: 2025/06/14 13:27
上次编辑时间: 2025/06/23 11:52
---

- 13:27 
	#编程 #python 
	# Python 多线程
	## 理论
	- Python 中默认情况下是主线程（进程启动后默认产生 `MainThread` ）先进行，主线程执行完后就退出了，此时子线程才会开始执行自己的任务直到任务结束（*见代码 1*）
	- Python 中每个线程的具体执行：（就绪态队列中）竞争获取 GIL $\to$ 执行代码直到 sleep 或者 python 虚拟机将其挂起 $\to$ 释放 GIL
		- 线程被阻塞有以下 3 种情况：
			1. 睡眠：线程主动调用 `sleep()` 或 `join()` 方法后
			2. 等待：线程中调用 `wait()` 方法，需要其他线程通过 `notify()` 来唤醒
			3. 同步：线程中获取线程锁，但是资源已经被其他线程占用
	- 多线程同步：一般在多线程代码中，总会有一些特定的函数或代码块不想被多个线程同时执行，如：修改数据库、更新文件或其他会产生程序冲突的类似情况。如果两个线程的运行顺序不同，他有可能产生不同的结果，或者造成执行的轨迹或行为不相同，这时我们就需要使用到多线程的同步
		1. `Lock` 互斥锁：一个线程使用某些共享内存时（加锁状态），其他线程必须等它结束（释放锁），才能使用这一块内存
			- 注意在嵌套锁时可能发生死锁
		2. `Rlock` 可重入锁： 与互斥锁的区别是，支持**同一个**线程中能多次获取锁（能够在同一线程中实现嵌套锁）
		3. `Semaphore` 信号量：表明当前的共享内存的限定使用线程数量（最多能有几个线程使用）
		![[Pasted image 20250614124903.png]]
	- Python 提供 `threading` 模块来创建和管理线程
		- `threading.current_thread()` 返回当前 `Thread` 对象
		- `threading.Thread(target,args) ` 用于创建线程对象， ` target ` 参数指定线程要执行的函数， ` args ` 是传递给该函数的参数
			- `start()` 启动线程
				- 是**非阻塞**的，本质上是将该线程==加入就绪队列，由操作系统来决定何时执行==，并且会立即返回控制权给主线程
			- `join([timeout])` 等待该线程结束，如果指定了 `timeout` 则最多等待 `timeout` 秒
				- 是**阻塞**的，用于暂停主线程（不参与 GIL 竞争，被阻塞处于等待状态），直到调用 `join` 的子线程执行完毕后再让主线程继续执行 （*见代码 2*）
			-  `is_alive()` 检查线程是否还在运行
		- `threading.Lock()` 生成锁对象，相当于通行证，当对一段代码加锁时，同一时间只有一个线程能运行此代码（*见代码 3*）
			- `acquire()` ：获取锁，如果未获取到锁会阻塞程序（同步阻塞），直到获取锁才会往下执行
			- `release()` ：释放锁（只能显式释放，遇到 I/O 操作子线程不会释放 Lock）
			- `locked()` ：判断锁的状态（被获取还是已释放）
		- `threading.Rlock()` 生成可重入锁对象，能够多次请求同一资源（*见代码 4*）
		- `threading.Semaphore(value=1)` 生成信号量对象，可以理解为内置计数器/可用资源数目，当计数器>0 时可以使用共享内存，如果<0 则被阻塞（*见代码 5*）
			- `acquire()` ：获取 1 个信号量，内置计数器 $-1$ ，如果内置计数器 $<0$ 则线程被阻塞
			- `release()` ：释放资源，内置计数器 $+1$
		- `threading.Condition(lock=None)` 生成条件锁对象（会创建一个底层锁 `Lock` 或 `RLock` 对象 ）用于调度多个线程，暂停线程执行 / 唤醒等待中的线程
			- `acquire()` ：请求底层锁
			- `release()` ：释放底层锁
			- `wait(timeout=None)` ：等待直到被通知（ `notify` ）或发生超时
				- 具体实现机制：（针对获取了底层锁的线程，不然你让它暂不暂停也没意义）每个调用该方法的子线程内部都会创建一个新锁 `waiter` ，通过嵌套 `waiter.acquire()` 来挂起线程，释放掉底层锁，将 `waiter` 加入等待队列 `waiters` ，最后又尝试获取 / 等待底层锁
			- `notify(n=1)` ：唤醒 n 个等待这个条件的线程
				- 具体实现机制：只能唤醒获得了底层锁的线程（不然唤醒也没意义），获取等待队列中的前 n 个 `waiter` ，唤醒 `waiter` （通过释放 `waiter` 锁 ），将 `waiter` 移到通知队列 `notifiers`
	- Python 提供 `concurrent.futures` 模块的 `ThreadPoolExecutor` 类来进行线程池的管理，使用线程池后不需要再反复创建和销毁子线程（这是需要消耗系统资源的），而是一次性创建一定数量的子线程，每个线程各分配一个任务，剩下的任务排队等待
		- `ThreadPoolExecutor(max_workers)` 创建最多 `max_workers` 数量的线程池
			- `submit(fn,/,*args,**kwargs)` ：提交线程需要执行的任务（函数名和参数）到线程池中，并返回该任务的句柄（ 即 `future` 对象，理解为在未来完成的操作，因为 `submit` 返回时任务并没有完成 ），是**不阻塞**的，立即返回
			- `shutdown(wait=True,*,cancel_futures=False)` ：关闭线程池，但是此方法是在池中所有待执行的 `future` 对象完成执行且释放已分配的资源后才会返回 （ `wait` 是否等待所有任务完成， `cancel_futures` 是否取消未开始的任务 ）
				- `ThreadPoolExecutor` 可以用上下文管理器，就是因为 `__enter__` 返回 `Executor` 实例，退出时 `__exit__` 就执行的 `shutdown()`
		- `Future` 类将可调用对象封装为异步执行，其实例 `future` 对象由 `Executor.submit()` 创建，可以理解为任务的返回容器，其中会储存任务的返回值和状态
			- `done()` ：判断该任务是否结束/调用取消
			- `cancel()` ：尝试取消调用，如果任务已经在线程池中运行就无法取消
			- `result()` ：获取任务的返回值，如果任务还没完成就一直等待（相当于这个方法是**阻塞**的）
	## 代码示例
	1. 代码 1：花费时间显示的是主线程耗时（0.001 s），子线程 `start` 后又将控制返回给主线程，待主线程结束再进行子线程
	```python
	import threading
	import time
	
	def run():
	    time.sleep(2)
	    print('当前线程的名字是： ', threading.current_thread().name)
	    time.sleep(2)
	
	if __name__ == '__main__':
	    start_time = time.time()
	    print('这是主线程：', threading.current_thread().name)
	    thread_list = []
	    for i in range(3):
	        t = threading.Thread(target=run)
	        thread_list.append(t)
	    for t in thread_list:
	        t.start()
	    print('主线程结束！' , threading.current_thread().name)
	    print('一共用时：', time.time()-start_time)
	'''
	这是主线程：MainThread
	主线程结束：MainThread
	一共用时：0.0010387897491455078
	当前线程的名字是：Thread-1 (run)
	当前线程的名字是：Thread-3 (run)
	当前线程的名字是：Thread-2 (run)
	'''
	```
	
	2. 代码 2：本质上是**主线程在第一个 `join` 就被阻塞**了，阻塞后主线程退出对 GIL 的竞争，3 个子线程竞争 GIL 遇到 I/O 操作（ `sleep(2)` ）释放 GIL，等待状态过 2 s 后又竞争 GIL 执行 `print` 操作，之后再同上。至于为什么要每个子线程都 `join` ，而不是某个子线程，是为了防止最后是该线程首先得到 GIL（随机，看操作系统分配）结束运行，那么之后主线程就会恢复运行，等其结束后再执行另外的子线程（**概率事件**），所以为了避免就每个子线程都 `join`
	```python
	import threading
	import time
	
	def run():
	    time.sleep(2)
	    print(f'当前线程的名字是：{threading.current_thread().name}')
	    time.sleep(2)
	
	if __name__ == '__main__':
	    start_time = time.time()
	    print(f'这是主线程：{threading.current_thread().name}')
	    thread_list= []
	    for _ in range(3):
	        t= threading.Thread(target=run)
	        thread_list.append(t)
	    for t in thread_list:
	        t.start()
	    for t in thread_list:
	        t.join()
	    print(f'主线程结束：{threading.current_thread().name}')
	    print(f'一共用时：{time.time()-start_time}')
	'''
	这是主线程：MainThread
	当前线程的名字是：Thread-1 (run)
	当前线程的名字是：Thread-3 (run)
	当前线程的名字是：Thread-2 (run)
	主线程结束：MainThread
	一共用时：4.002594709396362
	'''
	```
	- 线程执行 I/O 时会释放 GIL（例子中就是 `time.sleep(2)` ）
	- 时间线示意图：
	```plaintext
		0s    创建线程A → sleep(2) → 释放GIL
	       	  创建线程B → sleep(2) → 释放GIL
	          创建线程C → sleep(2) → 释放GIL
	 	2s    所有sleep同时完成 → 竞争GIL执行print
	```
	
	3. 代码 3：不使用锁输出 num=99，因为 `sleep(0.1)` 操作在多线程时会释放 GIL，给其他子线程运行（切换速度很快，小于 0.001 s），则所有子线程的 `num1` 都赋值 100
	```python
	import time
	import threading
	
	lock = threading.Lock()
	def func():
	    global num
	    # lock.acquire()
	    num1 = num
	    time.sleep(0.1)
	    num = num1 - 1
	    # lock.release()
	    time.sleep(2)
	
	num = 100
	l = []
	for _ in range(100):
	    t = threading.Thread(target=func)
	    t.start()
	    l.append(t)
	for t in l:
	    t.join()
	print(num) # 没有加锁是99，加锁是0
	```
	
	4. 代码 4：可重入锁
	```python
	import threading
	def func():
		n = 0
		lock = threading.Rlock()  # 如果是互斥锁，则会在第二个with lock处锁死，因为该锁已经被第一个with lock获取，且未释放，在此僵住
		with lock:
			for i in range(10):
				n += 1
				with lock:
					print(n)
	t = threading.Thread(target=func)
	t.start() 
	```
	
	5. 代码 5：信号量
	```python
	import time
	import threading
	import random
	
	# 创建信号量对象，信号量设置为3，最多有3个线程“并行”运行
	semaphore = threading.Semaphore(3)
	
	def func():
	    with semaphore:  # 运行结束后自动release
	        print(threading.current_thread().name + '获得信号量')
	        time.sleep(random.randint(1, 5))
	        print(threading.current_thread().name + '释放信号量')
	
	for i in range(10):
	    t1 = threading.Thread(target=func)
	    t1.start()
	'''
	Thread-1 (func)获得信号量  # 可以看到同时最多只有3个线程获得了信号量
	Thread-2 (func)获得信号量
	Thread-3 (func)获得信号量
	Thread-3 (func)释放信号量
	Thread-4 (func)获得信号量
	Thread-1 (func)释放信号量
	Thread-5 (func)获得信号量
	Thread-2 (func)释放信号量
	Thread-6 (func)获得信号量
	Thread-4 (func)释放信号量
	Thread-7 (func)获得信号量
	Thread-5 (func)释放信号量
	Thread-8 (func)获得信号量
	Thread-7 (func)释放信号量
	Thread-9 (func)获得信号量
	Thread-9 (func)释放信号量
	Thread-10 (func)获得信号量
	Thread-6 (func)释放信号量
	Thread-8 (func)释放信号量
	Thread-10 (func)释放信号量
	'''    
	```