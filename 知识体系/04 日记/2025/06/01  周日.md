---
创建时间: 2025/06/01 10:33
上次编辑时间: 2025/06/04 12:26
---

- 10:33 
	#健身 #功能训练/肩胛
	# 肩胛训练
	参考视频： [带小朋友备赛系列⑥\(得肩胛者得天下\)](https://www.bilibili.com/video/BV13t4y1G7Nx/?spm_id_from=333.1387.favlist.content.click&vd_source=85050722c3bd101265950cd0862f2dd9) 2022 年凯圣王视频
	- **功能训练**是服务于某个主要目标（比如三大项重量提升、扣篮、爬山等）的辅助训练模式，主要开发关节的稳定性、柔韧性、灵活度等基础，进而按需发展肌肉的力量、耐力、速度、爆发力等
	1.  开胸椎
		- 把胸椎段放在泡沫轴上，注意屁股坐实地面，头也往地上靠 👈 提高胸椎灵活度
		- 持续 1~5 min
	2. YTW（对应 3 个动作）
		- 现代人经常久坐、伏案 👉 肩胛提肌/上斜方肌紧张，中下斜方肌/菱形肌/肩胛下肌/前锯肌弱
		- 背躺在瑜伽垫上，下背平坦（骨盆后倾），下肢放松（避免竖脊肌发力），都可以加上肱骨旋外
			- Y：双手笔直斜向上（躯干和双手像字母 Y）👉 肩胛上回旋 - 下斜方肌
			- T：双手垂直放在身体两侧（躯干和双手像字母 T），肩胛可以稍许往上抬👉肩胛内收 - 中斜方肌/三角后束/肩袖
			- W：双手仍在身体两侧，相较于 T 稍微肩内收，屈肘 👉 肩胛内收/下降（注意同时进行，不是分开的）
		- 做 1~2 组，YTW 各 10~20 次（动作质量很重要，不要肌肉疲劳去继续做）
	3. 白蜡杆辅助训练（肩胛上下回旋/内收/下降）
		-  背躺在瑜伽垫上，掌心向下握住白蜡杆，低头（颈椎平），胸椎段微抬离地面
		- 离心时主动做上回旋
		- 2 组，1 组 20 次
	4. 交替触肩：稳定性训练
		- 动作类似平板支撑（背角是平的，核心收紧），用一只手去触对侧肩
	5. 引体：肩胛下降/下回旋
		- 窄握引体，肩胛下降/下回旋
	6. 支撑类：肩胛外展/内收
		- 双手宽支撑，新手建议膝盖跪在地上，外展时末尾用前锯肌
		- 拉力带锻炼/背靠墙顶墙（看肩有没有旋前）
	7. 前锯肌锻炼
		- 贴墙擦玻璃：沉肩，肘与手离墙 1 mm，五指并拢
- 15:35 
	#编程 #python 
	# 元类 Metaclass
	## 与元类相关的内置属性与魔法方法
	- python 中对象的内置属性 `__class__` 、 `__bases__` 、 `__slots__` 、 `__dict__`
		1. `__class__` ：对象的类型（表示这个对象是谁创建的实例）
		2. `__bases__` ：类对象的父类组成的元组（表示这个类继承的所有父类）
		3. `__slots__` ：使用时，只有 `__slots__` 中声明的属性才能被添加到类实例中，防止意外添加新属性
		4. `__dict__` ：查看对象内部所有属性名和属性值组成的字典
	- python 中的魔法方法 `__new__` 、 `__init__` 和 `__call__`
		1. `__new__(cls,*args,**kwargs)` ：负责对象的创建，是**类方法**（在调用时实例不存在，根本不会有 `self` ）；是在调用类名进行实例化时自动调用，要分配内存并**返回实例对象**（不能递归调用，需要用父类或者其他类的 `__new__` 创建对象）
		2. `__init__(self,*args,**kwargs)` ：负责对象的初始化，是对象方法；是在类每一次实例化对象后调用，不返回任何值（只刷新/更改实例对象的状态）
		3. `__call__(self[,...])` ：在类中**重载 `()` 运算符**，使得能够调用类实例对象（以 `对象名()` 形式 ）就像调用普通函数一样
			- ==实际上调用函数时== `func()` ==其实是== `func.__call__()` ==的简写==（函数对象都有 `__call__` 方法，而 `int` 、 `str` 等对象没有 `__call__` 方法，不可调用 ）
	## 元类意义
	- 元类 Metaclass 是 `type` 的子类，通过代替 `type` 的 `__new__` , `__init__` , `__call__` 等方法来创建或修改类，元类是可以对子类的属性进行修改的（正常情况下父类无法对子类属性进行操作）
		- 当使用元类时（语句 `class Foo(arg, metaclass = MyMeta)` ），Python 解释器在创建类时会通过 `MyMeta.__new__()` 来创建（而不是 `type` 的 ），此时可以修改类的定义等等
	```python
	class MyMeta(type):
	    def __new__(cls, *args, **kwargs):  # cls指元类，创建元类的类对象
	        print('===>MyMeta.__new__')
	        print(cls.__name__)
	        return super().__new__(cls, *args, **kwargs) 
	    def __init__(self, classname, superclasses, attributedict): # self指创建的类对象
	        super().__init__(classname, superclasses, attributedict)
	        print('===>MyMeta.__init__')
	        print(self.__name__)
	        print(attributedict)
	        print(self.tag)
	    def __call__(self, *args, **kwargs): # 当调用类对象时使用，即产生类对象的实例对象，self指类对象
	        print('===>MyMeta.__call__')  
	        obj = self.__new__(self, *args, **kwargs) # 2个self都是类对象：前者是用类对象的__new__方法，后者是__new__(cls=self,...)参数，意为创建的是类对象的实例对象
	        self.__init__(obj, *args, **kwargs) # self是类对象，表示用self的__init__方法，obj是实例对象，起指针的作用
	        return obj
	    
	class Foo(object, metaclass=MyMeta):
	    tag = '!Foo'
	    def __new__(cls, *args, **kwargs):
	        print('===>Foo.__new__')
	        return super().__new__(cls)
	    def __init__(self, name):
	        print('===>Foo.__init__')
	        self.name = name
	# ===>MyMeta.__new__
	# MyMeta
	# ===>MyMeta.__init__
	# Foo
	# {'__module__': '__main__', '__qualname__': 'Foo', 'tag': '!Foo', '__new__': <function Foo.__new__ at 0x000001B1B2379678>, '__init__': <function Foo.__init__ at 0x000001B1B2379708>, '__classcell__': <cell at 0x000001B1B23880A8: MyMeta object at 0x000001B1B1A509A8>}
	# !Foo
	foo = Foo('test')
	# ===>MyMeta.__call__
	# ===>Foo.__new__
	# ===>Foo.__init__        
	```
	## 元类应用
	1. ORM 框架（Object Relational Mapping，对象-关系映射）是把关系数据库的一行映射为一个对象，这样一个表就对应一个类
		- 所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来
		-