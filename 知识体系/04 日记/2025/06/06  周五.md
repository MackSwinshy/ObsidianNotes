
- 09:19 
	#编程/设计模式
	# 工厂模式
	## 简单工厂模式 Simple Factory
	- 也叫静态工厂方法 Static Factory Method，其实不属于 GOF 设计模式
	- 有一个工厂类负责创建其他多个不同类的实例对象，该工厂类通常包含一个公共方法，其接受一个参数，用于指示要创建的对象类型，然后根据该参数创建相应的对象并返回
	- 缺点：如果需要添加新的对象类型，则**必须修改工厂类的代码**；该模式也可能**破坏了单一职责原则**（除了创建实例，还负责判断要创建哪个实例的逻辑）
	```python
	class Product: # 产品基类
	    def operation(self):
	        pass
	 
	class ConcreteProductA(Product):  # 具体产品类，实现operation方法
	    def operation(self):
	        return 'ConcreteProductA'  
	
	class ConcreteProductB(Product):
	    def operation(self):
	        return 'ConcreteProductB'
	
	class SimpleFactory:
	    @staticmethod
	    def create_product(type): # 根据客户端传入的产品类型创建相应的产品对象
	        if type == 'A':
	            return ConcreteProductA()
	        elif type == 'B':
	            return ConcreteProductB()
	        else:
	            raise ValueError('Invalid product type') 
	
	if __name__ == '__main__':  # 客户端
	    product_a = SimpleFactory.create_product('A')
	    print(product_a.operation())  # Output: ConcreteProductA
	    product_b = SimpleFactory.create_product('B')
	    print(product_b.operation())  # Output: ConcreteProductB
	```
	## 工厂方法模式 Factory Method
	- UML 图：
		![[Pasted image 20250606105205.png]] 
	- 基本原理：
		1. 定义一个接口或抽象类来表示要创建的对象（Product）
		2. **将对象的创建过程委托给子类**：让子类决定实例化哪一个类， `FactoryMethod()` 使一个类的实例化延迟到其子类（==简单工厂模式只有一个工厂，工厂方法模式对每一个产品都有相应的子工厂==）
	```python
	from abc import ABC, abstractmethod
	
	class Product(ABC):  # 产品抽象基类
	    @abstractmethod
	    def use(self):
	        pass
	
	class ConcreteProductA(Product):
	    def use(self):
	        print('ConcreteProductA')
	
	class ConcreteProductB(Product):
	    def use(self):
	        print('ConcreteProductB')
	 
	class Creator(ABC):  # 工厂抽象基类
	    @abstractmethod
	    def factory_method(self):
	        pass
	    def an_operation(self):
	        product = self.factory_method()
	        product.use() # 产品都需要实现use方法
	
	class ConcreteCreatorA(Creator):
	    def factory_method(self):
	        return ConcreteProductA()
	
	class ConcreteCreatorB(Creator):
	    def factory_method(self):
	        return ConcreteProductB()
	        
	if __name__ == '__main__':
	    creator_a = ConcreteCreatorA()
	    creator_a.an_operation()  # Output: ConcreteProductA
	    creator_b = ConcreteCreatorB()
	    creator_b.an_operation()  # Output: ConcreteProductB
	```
	
	## 对比：为何需要用抽象基类
	1. `class Product(ABC)` **强制/规范**所有产品子类都必须实现统一接口（例子的 `use` 方法）
	2. `class Creator(ABC)` **扩展灵活性**，新产品的添加不需要修改现有的代码
		- 新增产品 `ConcreteProductC` 
			- 简单工厂（没有 `ABC` ）需要在 `SimpleFactory` 的 `create_product` 方法中进行修改，加上 `elif type == 'C'...` ，违背 OCP 原则
			- 工厂模式（有 `ABC` ）需要新写一个工厂子类 `ConcreteCreatorC(Creator)` ，不需要对原工厂类进行修改
		- 客户端调用
			- 简单工厂：需要知道产品类的细节（方法），因为是通过 `product_a.operation()` 调用；相当于要知道所有类的细节，比如工厂类的 `create_product` 方法和产品类的 `operation` 方法
			- 工厂模式：符合 DIP 原则，客户端代码仅依赖抽象接口，只用知道工厂类的细节即可，因为对产品的相关操作被封装到工厂类的 `an_operation` 中，不需要再显式调用产品类的方法
- 09:50 
	#编程/设计模式 
	# UML 类图
	- UML，Unified Modeling Language 统一建模语言，是面向对象建模的重要工具，用于描述系统的静态结构，展示类、接口及其之间的关系
	## 类图的基本元素
	1. 具体类
		- 矩形框分为 3 层，包含三部分：类名、属性（可选）和方法（可选）
		- 访问修饰符号（属性和方法前）： `+` 表示 `public` ， `-` 表示 `private` ， `#` 表示 `protected` ，不带符号是 `default`
	2. 抽象类
		- 与具体类差不多，但是抽象类的类名和抽象方法的名字都是 *斜体字* 来表示
	3. 接口
		- 矩形框分为 2 层，有两部分：接口的名字和方法
		- 第 1 层顶端加上 `<<interface>>` 表示
	## 类图中元素间的关系
	1. 实现关系 `implements`
		- 指接口与其实现类之间的关系
		- 箭头：虚线 + 空心三角，从实现类指向接口
		![[Pasted image 20250606093232.png]] 
	2. 继承关系
		- 箭头：实线 + 空心三角，从子类指向父类
		![[Pasted image 20250606093402.png]] 
	3. 关联关系
		- 对象和对象之间的连接，一个对象的属性有另一个对象
		- 箭头：实线 + 单箭头（单向关联）/ 双箭头或无箭头（双向关联），指向被关联/引用的
		![[Pasted image 20250606093641.png]] 
	4. 依赖关系
		- 一个对象是另一个对象方法的传递参数、返回值
		- 箭头：虚线 + 箭头，从使用方指向被使用方
		![[Pasted image 20250606093923.png]] 
	5. 聚合关系
		- 整体与部分之间是可分离的，它们可以具有各自的生命周期
		- 箭头：空心菱形 + 实线(箭头)，空心菱形在整体一方，箭头指向部分一方
		![[Pasted image 20250606094200.png]] 
	6. 组合关系
		- 整体与部分是不可分的，整体的对象负责部分的对象的生命周期
		- 箭头：实心菱形 + 实线(箭头)，实心菱形在整体一方，箭头指向部分一方
		![[Pasted image 20250606094320.png]] 
		 
- 15:33 
	#编程 #python 
	# 迭代器和生成器
	## 基础知识
	- 容器：存储某些元素/成员的数据集合/统称
		- 容器最显著的性质就是能判断一个元素是否在该容器内（ `in` 和 `not in` 关键字 ）
		- 原理：容器都实现了 `__contains__` 方法（只要实现 `__contains__` 方法的对象都是容器 ）
		```python
		def __contains__(self, item):
			return item in self.items
		``` 
		- 常见容器类型： `str` , `list` , `tuple` , `set` , `dict`
	- 迭代：是重复获取容器中元素的过程，一次只获取一个元素，直到从前往后遍历完所有元素
		- 提供了一种不依赖索引的取值方式
		- 是一个重复的过程，每一次重复都是基于上一次结果而来
	## 迭代器
	- 迭代器协议：指需要实现 `__iter__` 和 `__next__` 方法（类似上下文管理协议）
		- `__iter__` 返回对象本身，即 `self`
		- `__next__` 返回每次迭代的值，在没有可迭代元素时抛出异常 `raise StopIteration`
		- `iter()` 函数：用来获取一个可迭代对象的迭代器
		- `next()` 函数：用来获取迭代器的下一个值（从前往后）
	
	- 迭代器：实现了迭代器协议的对象（拥有 `__iter__` 和 `__next__` 方法），是可以迭代取值的对象
		- **可迭代对象**是指拥有 `__iter__` 方法的对象（包括 `str` , `list` , `tuple` , `set` , `dict` ，它们真正对应的迭代器都是 `str_iterator` , `list_iterator` ... ）
			- 或者定义为通过 `__iter__` 方法返回一个迭代器的都是可迭代对象
			- ==可迭代对象**不能直接迭代取值**，需要转化为迭代器后才能如此操作（它们没有 `__next__` 方法 ）==
			- `for` 循环本质上是先将可迭代对象转化为迭代器后，再不断调用 `__next__` 进行取值
	- 迭代器的特性
		- ==惰性计算==：提升内存效率，不会一次性生成所有数据而是在需要时按需生成，如此只占用有限的内存
		- ==不可逆性==：迭代器遍历完所有元素，就不能回溯到之前的状态，不支持反向迭代
	## 生成器
	- 生成器就是语法简化版的迭代器（自动实现迭代协议）
	- 创建生成器的方法
		1.  生成器函数：用 `yield` 关键字替换 `return` ，当函数被调用时就创建一个生成器对象
			- `yield` 对应的值不会在函数被调用时立刻返回，而是调用 `next` 方法后才返回（或者 for 循环，其本质就是调用 `next` 方法 ）
			- 生成器会记住上次的执行状态（每次执行时遇到 `yield` 就返回 `yield` 的结果，但内部会保留上次执行的状态，下次继续迭代时，会继续执行 `yield` 之后的代码，直到再次遇到 `yield` 后返回） 
		2. 生成器表达式：与列表表达式类似，但是返回的是生成器对象
	```python
	def gen(n): # 生成器函数
		for i in range(n):
			yield i
	g1 = gen(5) # 此时gen中代码并未执行，只是创建了个生成器对象
	print(g1) # <generator object gen at 0x...>
	print(next(g1)) # 0
	print(next(g1)) # 1
	
	g2 = (i for i in range(5)) # 生成器表达式，注意最外面是圆括号
	for i in g2:
		print(i, end = ' ') # 0 1 2 3 4 
	```
	- 生成器的其他方法（能该边内部的状态，生成器本来就能记住上次执行的上下文）
		1.  `send` 把外部的值传入到生成器内部，从而改变生成器的状态
			- `send` 是把值赋给 `j = yield i` 前面的 `j` ，而对 `i` 无影响， `i` 是继续执行之前的上下文
			- `send` 会唤醒生成器函数继续往下执行，相当于一次 `next`
		2. `throw` 外部向生成器内部传入一个异常
		3. `close` 手动关闭生成器，之后无法再进行操作 
- 16:32 
	#健身 #凯圣王训练营/一年级 
	# 一年级第 18 天 —— 快慢碳水与时间轴、身体代偿
	## 饮食结构
	1. 碳水的选择——快慢（膳食纤维）
		- 快慢取决于消化吸收速度，这又与膳食纤维含量有关
		- 膳食纤维/慢碳（红薯、玉米等）的优点：
			- 延长胃排空时间、延缓葡萄糖吸收、降低胆固醇水平、降低总热量、润肠通便
			- 但也不要只吃慢碳，会影响正常代谢
	2. 碳水种类在时间轴上的安排
		- 正常时间节点（不训练）
			- 早上：快碳+慢碳混合
			- 中午：快碳
			- 晚上：慢碳（睡前 3 h 尽量不吃，睡前控糖）
		- 训练
			- 训练前 ~2 h：慢碳
			- 训练前 ~15 min：快碳
			- 训练后：快碳
	## 身体结构
	1. 生活习惯改善（圆肩驼背、上斜方紧张、失代偿）
	2. 身体活动度受限与肌肉代偿 
- 18:14 
	#健身 #功能训练/胸椎肩胛
	# 胸椎肩胛的功能训练
	参考视频： [25个技能包！别让胸椎肩胛成为你进步的绊脚石！](https://www.bilibili.com/video/BV1qv4y1t7BE?spm_id_from=333.788.videopod.sections&vd_source=85050722c3bd101265950cd0862f2dd9)
	 