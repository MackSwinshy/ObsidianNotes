
- 12:17 
	#健身 #凯圣王训练营/一年级 
	# 一年级第 20 天 —— 水合作用与补水、孤立、训练强度
	## 饮食结构
	- 如何判断是否脱水：尿液颜色比色卡
		![[Pasted image 20250612120208.png]]
		- 1，2，3：水合状态良好；4，5：缺水；6，7，8：脱水
	## 周期结构
	- 训练强度的来源：神经募集感、重量、容量、运动强度
	 
- 15:55 
	#编程 #python 
	# 并发编程
	## 基本概念
	- CPU ：中央处理器 (Central Processing Unit)，是一块超大规模的集成电路，是计算机的运算核心和控制核心，可以解释计算机指令以及处理内存中的数据
		- 核心/内核：CPU 内部独立的完整处理单元，包含算数逻辑单元、寄存器、控制单元和缓存等基础组件
	- 并发编程：指同时执行多个任务的编程技术，能提高程序的执行效率、响应速度、隔离性与安全
		- 进程 Process：操作系统分配内存资源的基本单位
			- 每个进程创建时操作系统都会为其分配内存资源（代码区、数据区、栈区、堆区）
			- 进程本质上由**程序实例、数据和进程控制块**组成，是**资源容器**，内存地址是进程拥有的资源
			- 进程的上下文指一个程序执行时，CPU 中所有寄存器值、进程状态以及堆栈中的数据；当进程切换时需要保存原进程的上下文
		- 线程 Thread：CPU 调度和执行计算任务的基本单位
			- 线程本质是**代码执行的上下文环境**（不是代码本身这个静态指令序列），是寄存器值（保存临时计算结果）+栈（存储局部变量和函数调用链）+程序计数器（指向当前执行的指令）+线程控制块（操作系统管理线程的数据结构）
			- 线程是进程中的一个**执行单元**，一个进程可以包含多个线程，这些线程共享进程的内存空间和资源，但每个线程有自己的栈和程序计数器
			- 具体 CPU 调度过程包括时间片分配、线程队列以及上下文切换等
		- 协程 Coroutine：比线程更轻量级，在执行过程中可以暂停和恢复，从而实现非阻塞的并发执行
			- 协程是应用程序自身/用户来控制调度，而线程是操作系统内核来控制
		- 并发：指**一个时间段**内多个任务在同一 CPU 同时执行（但在任意时间点，只有一个程序在该 CPU 运行，其他程序挂起/等待）
		- 并行：指**某一时刻**多个任务同时进行（因为多个 CPU 可以同时进行不同线程）
		- GIL 全局解释锁，Global Interpreter Lock，是 CPython 解释器中对线程的限制，一个进程只有 1 个 GIL，而只有获得 GIL 的线程才能在 CPU 上运行（所以 Python 的多线程其实是假的）
			- GIL 是为了解决多线程共享内存的数据安全问题才引入的
			- 当线程计时器/执行时间超时后，当前线程释放 GIL
		- CPU 密集型 / 计算密集型：运行时间受限于 CPU 的性能，当系统运作 CPU 读写 IO（硬盘/内存）时，IO 可以在很短时间完成，而 CPU 还有需要运算需要处理，负载高
			- 表示该任务需要 CPU 进行大量运算，不存在阻塞
			- 线程 CPU 时间所占比例越高，需要越少的线程，一般与核心数相同即可
		- IO 密集型：运行时间受限于 IO 的性能，当系统运作时，是 CPU 在等待 IO 的读写操作，CPU 负载不高
			- 线程等待时间（等 IO 操作）所占比例越高，需要越多的线程，可以在等待时启用其他线程继续使用 CPU
	## Python 多线程
	- Python 中每个线程的具体执行：获取 GIL $\to$ 执行代码直到 sleep 或者 python 虚拟机将其挂起 $\to$ 释放 GIL
	- Python 中默认情况下是主线程（进程启动后默认产生 `MainThread` ）先进行，主线程执行完后就退出了，此时子线程才会开始执行自己的任务直到任务结束
		![[Pasted image 20250614124903.png]]
	- Python 提供 `threading` 模块来创建和管理线程
		- `threading.Thread(target,args)` 用于创建线程对象， `target` 参数指定线程要执行的函数， `args` 是传递给该函数的参数
		- `Thread` 类的方法：
			- `start()` 启动线程
				- 是**非阻塞**的，本质上是将该线程==加入就绪队列，由操作系统来决定何时执行==，并且会立即返回控制权给主线程
			- `join([timeout])` 等待该线程结束，如果指定了 `timeout` 则最多等待 `timeout` 秒
				- 是**阻塞**的，用于暂停主线程（不参与 GIL 竞争，被阻塞处于等待状态），直到调用 `join` 的子线程执行完毕后再让主线程继续执行
			- `is_alive()` 检查线程是否还在运行
	- 例子：
		```python
		import threading
		import time
	
		def run():
	    	time.sleep(2)
	    	print(f'当前线程的名字是：{threading.current_thread().name}')
	    	time.sleep(2)
	
		if __name__ == '__main__':
	    	start_time = time.time()
	    	print(f'这是主线程：{threading.current_thread().name}')
	    	thread_list= []
	    	for _ in range(3):
	        	t= threading.Thread(target=run)
	        	thread_list.append(t)
	    	for t in thread_list:
	        	t.start()
	    	for t in thread_list:
	        	t.join()
	    	print(f'主线程结束：{threading.current_thread().name}')
	    	print(f'一共用时：{time.time()-start_time}')
		'''
		这是主线程：MainThread
		当前线程的名字是：Thread-1 (run)
		当前线程的名字是：Thread-3 (run)
		当前线程的名字是：Thread-2 (run)
		主线程结束：MainThread
		一共用时：4.002594709396362
		'''
		```
		- 线程执行 I/O 时会释放 GIL（例子中就是 `time.sleep(2)` ）
		- 时间线示意图：
		```plaintext
		0s    创建线程A → sleep(2) → 释放GIL
	       	  创建线程B → sleep(2) → 释放GIL
	          创建线程C → sleep(2) → 释放GIL
	 	2s    所有sleep同时完成 → 竞争GIL执行print
		```