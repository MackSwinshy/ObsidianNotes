
- 09:44 
	#编程 #python 
	# 赋值与拷贝
	## 赋值与传参
	- 赋值（ 形如 `a = 1` ）就是把变量/标签贴给对象（对象有内存地址及储存的值）
		- ==变量本身存储的是指向对象的指针==
	- 传参本质是**传递对象的指针拷贝**，（可以理解为把参数这个变量/标签也贴在原对象），在函数代码体中对参数变量的修改/赋值要进一步判断是可变对象还是不可变对象
		- 如果是不可变对象参数就指向新对象，不影响原对象；可变对象就直接修改原对象
		```python
		a = '123'
		def foo(b):
	    	print('>>> before id(b):', id(b))
	    	b = '456'
	    	print('>>> after id(b):', id(b))
	
		print('>>> before id(a):', id(a))
		foo(a)   # 把a的值赋给b，即b变量标签贴在'123'上，后来撕下又贴在‘456’上
		print('>>> after id(a):', id(a))
		print(a)
		# >>> before id(a): 2369250781312
		# >>> before id(b): 2369250781312
	 	# >>> after id(b): 2369250782368
	 	# >>> after id(a): 2369250781312   对a变量没有影响，一直贴在‘123’上
	 	# 123
		``` 
		- 不可变对象： `int` , `float` , `str` , `tuple` , `frozenset` , `bytes`
			- 修改不可变对象会创建新对象（函数参数也会指向新的对象）
		- 可变对象： `list` , `dict` , `set` ，自定义类的实例
			- 可变对象支持原地址修改值
			- 本质是 `list` / `dict` / `set` 本身有个地址（一直不变，可以理解为盒子），里面的成员也有自己的地址（理解为盒子中的物品）
		```python
	 	a = [1]
	 ​
	 	def foo(b):
	     	b[0] = 2
	     	b.append(3)
	 ​
	 	print(">>> before id(a): ", id(a))  # 4471127880
	 	print(">>> before id(a[:]): ", [id(_) for _ in a]) # [4472230896]
	 	foo(a)
	 	print(">>> after id(a): ", id(a))   # 4471127880，不变
	 	print(">>> after id(a[:]): ", [id(_) for _ in a]) # [4472230992, 4472127648],变了
		```
		- 默认参数：函数定义在被解释器首次加载时就会评估默认参数的值，并将其储存在函数的 `__defaults__` 属性中（相当于**默认参数在函数定义时就会被计算并保留，而不是每次调用时重新创建**）
		```python
		def foo(a, b=[]):  # 默认参数是不可变对象还好，是可变对象就一直调用原实例
	     	b.append(a)
	    	 return b
		
		print(foo(1))  # [1]
		print(foo(1))  # [1,1]
		print(foo(1))  # [1,1,1]
		``` 
	## 浅拷贝与深拷贝
	- ==对于不可变对象，因为 Python 对其内存管理方式是**引用计数**，所以赋值 / 浅拷贝 / 深拷贝的内存地址还是**原地址**==
		- Python 不会对值相同的不可变对象，申请单独的内存空间，只会记录它的引用次数
	- 对于**可变对象**，拷贝/复制可以理解为创建原对象的新副本，并且新副本与原对象的**内存地址不一样**，所以两者毫无关联，独立操作
		- 浅拷贝： `b = a.copy()` a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象
			- 浅拷贝则会创建一个新的对象，至于对象中的元素，它依然会引用原来的物体
		- 深拷贝： `b = copy.deepcopy(a)` a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的
		- 原对象内部的不可变对象的改变，不会影响到新拷贝的对象（因为是不可变对象，只会撕掉原对象内部的标签，但不影响拷贝对象的标签）
	 
- 11:03 
	#编程 #python 
	# Python 的内存管理
	- Python 使用了自动化内存管理，这种垃圾回收机制（Garbage Collection）以**引用计数**为主，**标记-清除**和**分代收集**为辅，对内存中的无效数据进行回收
	## 对象的引用计数机制  Reference Counting
	- 当python的某个对象的引用计数为0时，该对象就成为要被回收的垃圾了；但并不是立马就回收，等到 `gc` 触发的时候才开始回收
		- 引用计数+1 的情况
			1.  对象被创建，例如 `a = 23`
			2. 对象被引用，例如 `b = a`
			3. 对象被作为参数，传入到一个函数中
			4. 对象作为一个元素，存储在容器中
		- 引用计数 -1 的情况
			1. 对象的别名被显示销毁，例如 `del a`
			2. 对象的别名被赋予新的对象，例如 `a = 24`
			3. 一个对象离开它的作用域，例如 f 函数执行完毕时，f 函数中的局部变量
			4. 对象所在的容器被销毁，或从容器中删除对象
	## Python 的内存池
	1. 栈区与堆区：内存管理回收的是**堆区**的内容（栈区直接被`del` ）
		- 栈区：储存变量的名字和指针（与值内存地址的关联关系）
		- 堆区：储存对象的值和内存地址
	2. 直接引用与间接引用
		- 直接引用：从栈区出发直接能到达堆区的值内存地址
		- 间接引用：从栈区出发引用到堆区后，再通过进一步引用才能到达的内存地址
		```python
		l2 = [20, 30]
		x = 10
		l1 = [x, l2]
		```
		![[   Pasted image 20250603104438.png]]
	3. 缓存池
		- 为了优化性能，Python实现了对象缓存池机制，即对一些常用对象进行复用，而不是重新创建新对象
		- 驻留（Interning）优化 / 私有内存池
			- 小整数： $[-5,256]$ 之间的整数数字
			- 符合标识符的字符串（只包含字符、数字、下划线）
			- 字符串长度为 0 或 1
		```python
		a=1
		b=1
		print(id(a) == id(b))  # True
		``` 
	## GC 的辅助方案
	1. 标记-清除 Mark and Sweep
		- 为解决**循环引用**的问题（即使删除变量，值的引用计数都不为 0，内存空间无法回收）
		- 标记-清除的做法是当应用程序可用的内存空间被耗尽时，会停止整个程序，然后进行标记与清除
			- 标记：遍历所有的 `GC Roots` 对象 (**栈区**中的所有内容或者线程），然后将所有 `GC Roots` 对象可直接或间接访问到的（堆区中）对象标记为存活；其余的均为非存活，应该被清除
			- 清除：该过程会遍历**堆中**所有的对象，将没有标记的对象全部清除掉
	2. 分代收集 Generation Collection
		- 为解决**效率问题**（每次回收内存，都需要把所有对象的引用计数都遍历一遍，非常消耗时间）
		- 分代收集的做法是用空间换时间（历经多次扫描的情况下都没有被回收的变量，gc 机制会认为该变量是常用变量，对其扫描的频率会降低）
			- 分代：根据存活时间来为变量划分不同等级（也就是不同的代）
			- 等级（代）越高，被垃圾回收机制扫描的频率越低
	 
- 13:59 
	#健身 #功能训练 
	# 静态拉伸
	## 拉伸的好处
	1. 提高肌肉的延展性 / 活动度
	2. 帮助激活副交感神经，有助于放松 
	## 不同部位的具体拉伸方式 （徒手）
	- 任何拉伸动作都可以用结合 PNF 拉伸（只要不太痛，控制 RPE 6~7 间），先静态拉伸 10 s，PNF 主动对收缩 7~10 s，最后再静态拉伸 20~30 s；注意配合呼吸
	1. 小腿（腓肠肌 / 比目鱼肌）：重复 20~30 s 即可
		- 双手放墙上，前后脚都踩实地面，前后脚都屈膝往前顶膝盖，整个躯干也跟着往前动（拉伸深层比目鱼肌）
			- 屈膝时是把腓肠肌的近端缩短，抑制其拉伸；参与更多的是单关节比目鱼肌的拉伸
			![[Pasted image 20250603115728.png]]
		 - 其他相同，后腿膝盖打直（拉伸腓肠肌）
		  ![[Pasted image 20250603115849.png]]
	2. 腘绳肌
		- 找个凳子，单边身体坐在凳子上，另一边大腿往后伸（屏蔽该侧髋关节），腰是伸直的（不要大幅弯腰，避免腰部代偿），躯干往前倾，双手触脚
		![[Pasted image 20250603120347.png]]
	3. 臀大肌：功能是让髋部后伸、旋外
		- 用我们的脚向里去移动，脚移到另一只腿膝盖外侧的位置，保住膝盖外侧, 躯干对侧旋转
		![[Pasted image 20250603120625.png]]
	4. 股四头肌
		- 侧躺在垫子上，胳膊垫在头下方，手抱在脚踝的正前方（胫骨上），向后伸展大腿
		- 抓脚踝时不要屈髋，要在伸髋（大腿起码平行躯干）；最大程度屈膝，控制不要出现髋外展（因为阔筋膜张肌紧张），要在内收状态下进行伸展
		![[Pasted image 20250603120831.png]] 
	5. 髂腰肌：功能使骨盆前倾（起止点是骨盆和腰椎横突）
		- 类似单膝下跪，躯干首先是中立位，然后骨盆向后做后倾的状态（收紧腹肌和臀大肌）
		- 如果延展性可以，在骨盆后倾状态下，腰部往前方移动进一步伸展
		![[Pasted image 20250603121334.png]]
	6. 内收肌
		- 双膝跪地，把要拉伸一侧腿向外延展，同时脚尖朝前；另一只腿脚掌在髋关节正下方的线上；双手撑地，拉伸侧延展到最大幅度
		 ![[Pasted image 20250603133957.png]]
	7. 背阔肌：让手臂旋内+内收
		- 跪姿：屈髋，身体向外延展，想拉伸侧手臂外旋（掌心朝上），同时手向身体对侧移动
		![[Pasted image 20250603134241.png]]
		-  站姿：拉伸侧手旋内，搭在与肚脐等高的把手上，同时躯干向同侧旋转
		![[Pasted image 20250603134434.png]] 
	8. 胸大肌：让手臂屈曲、内收、旋内
		- 拉伸侧手搭在墙上，手肘与肩同高，弓步站立（哪只脚在前无所谓），进行胸部的旋转和伸展
		- 根据手肘位置的高低以及胸部肌纤维的走向，可以拉伸到不同的胸大肌肌纤维
		![[Pasted image 20250603134624.png]]
	9. 三头肌：伸肘
		- 手靠墙壁，肘关节朝上，进行屈肘（增加强度：对侧手抱住肘关节的外侧）
		![[Pasted image 20250603134946.png]] 
	10. 二头肌：肩屈、肘屈、小臂旋外
		- 找一把手，手往后伸扶在把手上（掌心朝下，旋内），找到合适高度感受被拉伸，肩不要旋转（手臂旋转就行）不要耸肩
		![[Pasted image 20250603135236.png]] 
	11. 小臂肌群
		- 腕关节屈肌：手臂打直向外伸，做外旋，用另一只手侧向扶住手掌
		![[Pasted image 20250603135512.png]] 
		- 伸腕肌群：屈腕
		![[Pasted image 20250603135645.png]]  
	 