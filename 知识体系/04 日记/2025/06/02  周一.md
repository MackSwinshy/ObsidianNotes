
- 09:13 
	#编程 #python #具体函数 
	# python 中的 ABC 模块
	1. `ABCMeta` （ABC：Abstract Base Class 抽象基类），当使用抽象元类时（ `metaclass = ABCMeta` ）时，子类继承就必须父类中指定的功能（通过语法糖 `@abstractmethod` ）；子类如果不实现父类的 `abstracmethod` ，子类实例化时就会报错 `TypeError`
	2. `@abstractmethod` 是 `abc` 模块中的装饰器，用于声明抽象方法
		- 抽象方法是在抽象基类中**声明但没有实现**的方法，它存在的意义是为了定义一个接口，来规范子类必须实现该方法
	- 示例：使用抽象类定义一个 `Shape` 类，并要求其子类必须实现 `area` 方法
	```python
	from abc import ABCMeta, abstractmethod
	
	class Shape(metaclass=ABCMeta):
	    @abstractmethod
	    def area(self):
	        pass
	
	class Rectangle(Shape):
	    def __init__(self, width, height):
	        self.width = width
	        self.height = height
	    def area(self):
	        return self.width * self.height
	
	class Circle(Shape):
	    def __init__(self, radius):
	        self.radius = radius
	    def area(self):
	        return 3.14 * self.radius * self.radius
	
	# 创建对象并调用方法
	rectangle = Rectangle(5, 10)
	print("Rectangle Area:", rectangle.area())
	circle = Circle(3)
	print("Circle Area:", circle.area())
	
	# 尝试创建抽象类的实例
	shape = Shape()  # 抛出 TypeError 异常
	``` 
- 09:24 
	#编程 #python #具体函数 
	# 工厂类
	- 意义：将对象创建与使用解耦，客户端代码无需知道具体类名，就可以通过工厂类来创造不同类的实例对象
		- 新增不同类时只需修改工厂类，保持客户端代码稳定 
- 09:57 
	#编程 #python 
	# 类与类之间的关系
	1. is-a 关系：继承
		- 子类在不影响父类的程序运行的基础上对父类进行的扩充和扩展
	2. has-a 关系：关联 / 聚合 / 合成
		- 关联：将一个类的对象封装到另一个类的对象的属性中
		- 聚合：关联关系的特例，是多个类的对象聚合到另一个类的对象属性中，并且各自有各自的声明周期（比如电脑，电脑中有 CPU, 硬盘, 内存等等, 电脑坏了，但 CPU 可能是好的）
		- 合成：关联关系的特例，关系更紧密，声明周期一致（比如人，人有各个器官，当人挂了器官也挂了）
	3. use-a 关系：依赖
		- 将一个类的类名或对象当作参数传递给另一个类的方法被使用的关系
	```python 
	# 大象进冰箱
	class Elphant:
	    def __init__(self, name):
	        self.name = name
	    def open(self, ref):  # 冰箱类的对象作为参数传递
	        print("大象要开门了. 默念三声. 开!")
	        # 由外界传递进来一个冰箱, 让冰箱开门, 这时大象不用背着冰箱到处跑.
	        ref.open_door()
	    def close(self, ref):
	        print("大象要关门了. 默念三声. 关!")
	        pass
	    def take(self):
	        print("钻进去")
	 
	class Refrigerator:
	    def open_door(self):
	        print("冰箱门被打开了")
	    def close_door(self):
	        print("冰箱门被关上了")
	# 造冰箱
	r = Refrigerator()
	# 造大象
	el = Elphant("神奇的大象")
	el.open(r) # 注意,此时是把一个冰箱作为参数传递进去了,也就是说,大象可以指定任何一个冰箱.
	el.take()
	el.close(r)
	```
	 
- 10:57 
	#编程 #python #具体函数 
	# `enum` 模块
	- 该模块提供了创建和管理枚举类型的强大工具：通过不同的枚举类，使用者能根据需求选择合适的枚举类型，装饰器也确保枚举的正确性和规范性
		- 枚举的枚举项（key）不能重读，枚举项的值不应该能够在外部进行修改（应该是常量）
	- 枚举：把符号名称（成员）和唯一值绑定
	1. `Enum` 类
		- 自定义的枚举类继承 `Enum` 基类，类中每个声明就是枚举成员（本质是枚举类的实例对象）
		- 成员属性有 `name` （枚举成员的名称）和 `value` （枚举成员的绑定值）
		```python
		from enum import Enum
	 	class Color(Enum):
	    	RED = 1   # RED=1整体代表一个枚举成员对象，RED是name属性，1是value属性
	     	GREEN = 2
	     	BLUE = 3
		``` 
		- 成员访问：按值访问 （ `Color(2)` 返回 `Color.GREEN` )；按名称访问（ `Color['BLUE']` 返回 `Color.BLUE` ）
		- 使用 `auto` 函数可以自动为枚举成员选择合适值（ `Enum` 是从 1 递增 ）
	2. `@unique` 装饰器
		- 确保枚举类中每个成员的 `value` 都是唯一的，防止重复值带来混淆 
	3. `@verify()` 装饰器
		- 结合 `enum` 模块中提前定义好的选项，检查枚举是否满足特定约束
			- `UNIQUE` 约束：与 `@unique` 相同左右  （写作 `@verify(UNIQUE)` ）
			- `CONTINUOUS` 约束：确保所有枚举成员的值是连续的，没有缺失值，适用于整数值成员 
- 11:51 
	#编程 #python #具体函数 
	# `@property` 装饰器
	1. 是 python 的内置函数，它把类中的方法包装成属性，**让方法可以以属性的形式被访问和调用** 
		- 核心价值是实现了**属性访问的封装与控制**
			- **统一访问接口**：都是用属性的访问语法，而不是方法调用，方法与属性统一
			- **访问控制集成**：在一个属性上集成读取、赋值、删除的完整控制（对比私有属性）
			- 兼容性保障：未来需要更改代码直接在 `@语法糖` 中修改，不需要动外部代码
		- 应用场景：在获取、设置和删除对象属性时，需要额外做一些工作（如过滤、筛选等）；或者需要限制对象属性的设置和获取
	2. 本质函数： `property(fget=None,fset=None,fdel=None,doc=None) -> property attribute`
		- `fget` 是**获取**属性值的方法（读）
		- `fset` 是**设置**属性值的方法（写）
		- `fdel` 是**删除**属性值的方法
		- `doc` 是属性描述信息，如果省略会使用 `fget` 方法的 `docstring`
	3. 语法糖
		- `@property` 本质上是 `getter` 方法，是获取属性值的方法，被装饰方法的名字会被用做属性名
		- `@属性名.setter`装饰的方法是设置属性值的方法
		- `@属性名.deleter` 装饰的方法是删除属性值的方法
	
	- 例子：使用与不适用 `@property` 的对比，管理实例属性
	```python
	# 不使用装饰器，直接对普通实例属性进行访问、修改、删除（有过滤条件，如果没过滤条件还是差不多的）
	class Paper:
	    def __init__(self):
	        self.score = 85
	    def get_score(self):                 # 定义一个方法 get_score() 用来获取分数
	        if self.score < 60:   # 过滤条件
	            return "你妹的，不及格！"
	        else:
	            return self.score
	    def set_score(self, value):          # 定义一个方法 set_score() 用来输入分数
	        if 0 <= value <= 100:  # 过滤条件
	            self.score = value
	        else:
	            print(f"输入的值 {value} 超出范围 0~100 ！")
	    def del_score(self):                 # 定义一个方法 del_score() 用来删除分数
	        del self.score
	        print("完成 score 属性的删除！")
	  
	paper = Paper()
	paper.set_score(99)           # 通过实例对象调用 set_score() 方法来实现 score 属性的赋值或修改
	print(paper.get_score())      # 通过实例对象调用 get_score() 方法来实现 score 属性的访问
	paper.del_score()             # 通过实例对象调用 del_score() 方法来实现 score 属性的删除
	```
	
	```python
	# 使用装饰器
	class Paper:
	    def __init__(self):
	        self._score = 85   # 设置成受保护成员，是为了防止和变成属性后的方法score重名
	  	@property
	    def score(self):
	        if self.score < 60:
	            return "你妹的，不及格！"
	        else:
	            return self.score
	  	@score.setter
	    def score(self, value):  # 附加方法与原始的特征属性要有相同的名称，所以都是score
	        if 0 <= value <= 100:
	            self.score = value
	        else:
	            print(f"输入的值 {value} 超出范围 0~100 ！")
	  	@score.deleter
	    def score(self):
	        del self.score
	        print("完成 score 属性的删除！")
	  
	paper = Paper()
	c.score = 45          # 直接使用实例对象调用 score.setter 进行赋值，背后还是调用了方法实现了过滤
	print(c.score)        # 获取 score 的值，通过score.getter
	del c.score           # 删除 score
	```
	- 在对属性操作（读写删）过程中有其他操作（验证、过滤等）情况时，不用装饰器就需要显式调用各种不同的方法，而用装饰器就能直接对方法变成的属性进行操作（虽然两者都是把具体代码逻辑写在方法中），更直观简洁
	- 如果只有 `@property` 那这个属性是只读不写的 
- 14:45 
	#健身 #凯圣王训练营 
	# 一年级第 15 天 —— 热量消耗与减脂关系、深蹲结构
	## 饮食结构
	1. 身体消耗热量的方式与减脂的关系
		1. 基础代谢：与体表面积 & 瘦体重 正相关
		2. 生长发育：青春期时身体发育需要热量 （成年后通过抗阻/力量训练让身体又进入生长期--肌肉）
		3. 体力活动：力量训练更有助于减脂（本身消耗热量、糖原、身体生长发育需要热量↑、提高基础代谢）
		4. 食物热效应：与饮食相关（主要是蛋白质 40%），是消化食物所需要付出的热量
	## 动作结构
	1. 深蹲结构：不要着急加重量，打磨动作质量
		- 重心
		- 髋膝节律
		- 背刚性 