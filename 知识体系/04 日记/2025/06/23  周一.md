
- 09:51 
	#编程/算法 
	# 第 2 章 -- 空间复杂度
	- 用于衡量随着输入数据量变大时，算法占用内存空间的增大趋势
	## 算法相关空间
	- 输入空间：储存算法的输入数据
	- 缓存空间：储存算法在运行过程中的变量、对象、函数上下文等数据
		- 暂存数据：保存算法运行过程中的各种常量、变量、对象等
		- 栈帧空间：用于保存调用函数的上下文数据，系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放
		- 指令空间：保存编译后的程序指令，在实际统计中通常忽略不计
	- 输出空间：储存算法的输出数据
	- 在分析空间复杂度时，通常分析**暂存数据、栈帧空间和输出数据**三部分
	## 推算方法
	- 统计对象是使用空间大小，通常只关注**最差**空间复杂度
		- 最差指最差的输入数据；或者是算法运行中的峰值内存
	- 递归函数需要统计栈帧空间：
	```python
	def function() -> int:
	    # 执行某些操作
	    return 0
	
	def loop(n: int):
	    """循环的空间复杂度为 O(1)"""
	    for _ in range(n):
	        function()
	
	def recur(n: int):
	    """递归的空间复杂度为 O(n)"""
	    if n == 1:
	        return
	    return recur(n - 1)	
	```
	- 循环函数 `loop` 虽然在循环中调用了 n 次 `function` ，但每次 `function` 都返回并释放了栈帧空间，因此空间复杂度仍为 1
	- 递归函数 `recur` 在运行过程中会同时存在 n 个未返回的 `recur` ，从而占用 $O(n)$ 的栈帧空间
	## 常见类型
	- $O(1)<O(log\,n)<O(n)<O(n^2)<O(2^n)$
	1. 常数阶 $O(1)$
		- 常见于数量与输入数据大小 𝑛 无关的常量、变量、对象
		- 在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间（**变量复用机制**：每次循环时，原变量会绑定到新的对象，旧对象如果没有其他引用会被立即销毁）
		```python
		def function() -> int:
	     	# 执行某些操作
	     	return 0
	 
	 	def constant(n: int):
	     	# 常量、变量、对象占用 O(1) 空间
	     	a = 0
	     	nums = [0] * 10000
	     	node = ListNode(0)
	     	# 循环中的变量占用 O(1) 空间
	     	for _ in range(n):
	         	c = 0
	     	# 循环中的函数占用 O(1) 空间
	     	for _ in range(n):
	         	function()
		```
	2. 对数阶 $O(log\,n)$
		- 常见于分治算法，例如归并排序，输入长度为 𝑛 的数组，每轮递归将数组从中点处划分为两半，形成高度为 $O(log\,n)$ 的递归树，使用 $O(log\,n)$ 栈帧空间
	3. 线性阶 $O(n)$
		- 常见于元素数量与 𝑛 成正比的数组、链表、栈、队列等
		- 长度为 n 的列表空间复杂度是 $O(n)$ 的原因是列表**存储 n 个引用地址**的内存消耗（不管是不是对同一个对象的引用）
		```python
		def linear(n: int):
	    	 # 长度为 n 的列表占用 O(n) 空间
	     	nums = [0] * n
	     	# 长度为 n 的哈希表占用 O(n) 空间
	     	hmap = dict[int, str]()
	     	for i in range(n):
	         	hmap[i] = str(i)
		```
	4. 平方阶 $O(n^2)$
		- 常见于矩阵和图，元素数量与 𝑛 成平方关系
		```python
		def quadratic(n: int):
	    	 # 二维列表占用 O(n^2) 空间
	     	num_matrix = [[0] * n for _ in range(n)]
		def quadratic_recur(n: int) -> int:
	     """平方阶（递归实现）"""
	     	if n <= 0:
	         	return 0
	     	# 数组 nums 长度为 n, n-1, ..., 2, 1，平均长度为n/2，递归深度为n，总体占用O(n^2)空间
	     	nums = [0] * n
	     	return quadratic_recur(n - 1)
		``` 
	5. 指数阶 $O(2^n)$
		- 常见于二叉树
		```python
		def build_tree(n: int) -> TreeNode | None:
	     	"""指数阶（建立满二叉树）"""
	     	if n == 0:
	         	return None
	     	root = TreeNode(0)
	     	root.left = build_tree(n - 1)
	     	root.right = build_tree(n - 1)
	     	return root
		```
- 10:00 
	#编程 #python 
	# 列表乘法细究
	- 列表乘法的本质就是浅复制，其会创建一个新列表对象，但是其中的每个元素都是对原列表成员对象的引用，此时就需要注意区分原对象是可变还是不可变
	```python
	# 不可变对象
	a = [0] * 3
	a[0] = 1 # 输出：[1,0,0]，不能改变原对象int 0，所以只能新建一个int 1
	# 可变对象
	b = [[0]] * 3
	b[0][0] = 1 # 输出：[[1],[1],[1]]，直接改变原对象[0]->[1]
	```
	
	- 对于不可变对象，赋值操作会创建一个新对象（重新绑定引用），而可变对象是可以原地修改
	```plaintext
	一维列表：
	[地址A(int 0)] → int 0
	                ↗ ↑ ↖
	           a[0] a[1] a[2]
	
	修改后：
	[地址B(int 1)] [地址A(int 0)] [地址A(int 0)]
	
	二维列表：
	[地址X(list[0])] → list [0]
	          	       ↗ ↑ ↖
	              c[0] c[1] c[2]
	
	修改后：
	[地址X(list[1])][地址X(list[1])][地址X(list[1])]
	```
	
	 
- 12:15 
	#编程/设计模式 
	# 单例模式 Singleton
	## 前置信息
	- 目的：确保一个类只有一个实例，并提供一个能访问该实例的全局访问点
	- 价值：有效地**避免重复的内存分配**（尤其当对象需要被频繁创建和销毁时），并且能较简单地控制全局状态（因为只有 1 个实例存在）
		- 但可能会导致线程安全问题，需要注意
	- UML 类图：
		![[Pasted image 20250623110807.png]]
	## 实现方法
	1. 使用装饰器 （该方法特点是**替换了类的调用方式**，在闭包函数中才是真正创建实例的地方）
		```python
		def Singleton(cls):
	     	_instance = {}
	     	def _singleton(*args, **kargs):
	         	if cls not in _instance:
	             	_instance[cls] = cls(*args, **kargs)
	         	return _instance[cls]
	     	return _singleton
	 
	 	@Singleton
	 	class A(object):
	     	a = 1
	     	def __init__(self, x=0):
	         	self.x = x
	 
	 	a1 = A(2)
	 	a2 = A(3)
	 	print(a1.x)  # 2
	 	print(a2.x)  # 2，因为在a2=A(3)时会直接返回_instance[A]就是A(2)这个实例对象
		``` 
		- 装饰器的具体实现步骤： `@Singleton` 语法糖执行 `A = Singleton(A)` $\to$ 返回 `_singleton` 函数 $\to$ 变量类名 A 绑定了 `_singleton` 函数对象而非原本的类对象
	2. 使用类的 `__new__` 方法（**能够和正常实例化对象的形式一样**，而不用显式调用类的某个静态单例方法）
		```python
		import threading
		
		class Singleton:
			_instance = None
			_lock = threading.Lock()		
			def __init__(self):
				pass
			
			def __new__(cls):
				if not cls._instance: # 双重检查
					with cls._lock:
						if not cls._instance:
							cls._instance = super().__new__(cls)
				return cls._instance
		```
		-  **双重检查锁定模式**（Double-Checked Locking）：==第 1 个检查避免每次获取实例都要加锁==（减少同步的开销）；加锁是保证线程同步安全；==第 2 个检查是防止有多个线程同时通过第 1 层检查后重复创建多个实例==（如果不检查，可能的情况就是有多个线程通过第 1 个检查，因为此时确实没有实例，之后在 lock 处等待，创建多个实例）
- 14:11 
	#健身 #凯圣王训练营/一年级 
	# 第 22 天 —— 碳水的分类、拮抗肌
	## 饮食结构
	1. 碳水的分类：精制糖（单糖、双糖）、寡糖（运动饮料）、多糖
	## 身体结构
	1. 拮抗肌对体态的影响 
- 14:33 
	#健身 #凯圣王训练营/一年级 
	# 第 23 天 —— 体重浮动、卧推分类
	## 饮食结构
	1. 处理身体水肿：睡前的最后 500 mL 水必须是蒸馏水（不是指时间点卡在睡前喝）、晚上低盐
	2. 体重指标
		- 短期指标：与水分变化、新陈代谢有关
			- 短期 7 天运动、力量训练后体重增加：随着开始训练，肌肉储糖能力开始增强，糖原储备量提高，储水能力也随着增加（1 g 肌糖原~3 g 水）
		- 长期指标：与脂肪增减、肌肉增减有关
	## 动作结构
	1. 健美式卧推与力量举卧推
		- 健美：孤立刺激胸大肌（水平内收），肩胛顶出去固定住，不会起桥
		- 力量举：（目的：推起更大重量）不孤立，离心时肩胛下回旋，让整个背阔肌也参与离心抗阻
	## 周期结构
	1. 练前预募集：起码半小时以上（较难） 