
- 09:34 
	#编程 #python #具体函数 
	# `contextlib` 模块
	
	- `contexrmanager` 装饰器
		- 核心意义：不需要为了构建一个上下文管理器而繁杂地写一个类出来，直接通过装饰函数就可以实现上下文管理，而且该函数也可以复用
		- 被装饰的函数在被调用时，必须返回一个生成迭代器（generator-iterator），这个迭代器通过 `yield` 关键字返回一个对象，这个对象会被用在 `with` 语句中，绑定到 ` as ` 后面的变量
			- `yield` 语句之前的代码当作 `__enter__` 方法执行，之后的代码当作 `__exit__` 执行
			- 如果要处理异常还是在函数体内写 try-finally 语句
		```python
		from contextlib import contextmanager
		@contextmanager
		def open_func(file_name):
			print('open file:', file_name, 'in __enter__')
			file_handler = open(file_name, 'r')
			
			try:
				yield file_handler
			except Exception as ecx:
				print('the exception was thrown')
			finally:
				print('close file:', file_name, 'in __exit__')
				file_handler.close()
				return
		with open_func('test.txt', 'r') as f:
			for line in f:
				1/0  # 捕获异常进入except语句，结束block代码块执行（print line），接着进入finally语句体
				print(line) 	
		```   
- 11:14 
	#编程 #python 
	# 异常处理
	- 核心意义：当程序运行时，如果发生当初编写代码未曾遇见的特殊情况（如文件不存在、网络连接失败等），通过异常处理捕获异常采取相应措施（比如给出错误提示、重试、记录日志等），而不是程序直接中断崩溃
	- `try-except-else-finally` 语句
		- `try` 代码块中检测到错误触发后，退出 `try` 块，执行匹配异常类型的 `except` 块，最后执行 `finally` 块
	- `raise` 语句
		- 主动抛出异常
	```python
	def input_number():
	    result = input('请输入密码：')
	    if len(result) >= 8:
	        return result
	    print('主动抛出异常')
	    ex = Exception('密码长度不够')  # Exception类实例化输入的参数都保存在异常对象的args属性中，同时也对__str__方法做出参数输入
	    raise ex  
	try:
	    print(input_number())
	except Exception as result:
	    print(result)  # 调用异常对象result的__str__方法
	```
	
	## 标准异常
	- 异常也是 Python 的对象，异常对象也具有属性
		1. `args` 存储传递给异常构造器的参数的元组
		2. `__traceback__` 异常的堆栈追踪信息
		3. `__context__` 异常链出现时保存原始异常上下文
		4. `__cause__` 显式指定的异常原因（使用 `raise from` 语法时 ）
	- 标准异常类型
	 ![[标准异常]]
	
	 
- 11:34 
	#编程 
	# 面向对象设计原则
	- 总结：**降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性**
	1. 开闭原则 OCP, Open Closed Principle
		- 软件实体/程序应该对扩展开放对修改关闭（封装性）
		- 开：允许一个类/甚至一个系统随时可以对自己的功能进行扩展
		- 闭：不允许在扩展和修改功能的时候触及到已经写好的底层代码（比如父类）
	2. 单一职责原则 SRP, Single Responsibility Principle
		- 一个类只做该做的事情（类的设计要高内聚）
		- （耦合性）一个类能被修改的原因只能有一个，发生其他问题都不会触及到该类
	3. 依赖倒转原则 DIP, Dependency Inversion Principle
		- 面向抽象编程，通过把传统的依赖具象代码关系转变成依赖抽象代码方式（接口）；客户端代码(调用的类)尽量依赖(使用)抽象的组件；抽象的是稳定的，实现是多变的
		- 这样不用每次变化代码后，都要重新写/修改固定代码的调用部分
		![[Pasted image 20250605112559.png]] 
	4. 里氏替换原则 LSP, Liskov Substitution Principle
		- （继承关系）任何时候可都要用子类对象替换掉父类对象
		- 里氏替换进一步要求父类尽可能不要存在太具体的功能，能抽象就尽量抽象，**任何的修改都完全依靠子类来补充和修改**，从而进一步实现开闭原则（**父类对修改关闭，子类对修改开放**）
	5. 迪米特法则 LoD, Law of Demeter
		- 最少知识原则，指类与类交互时，在满足功能要求的基础上，传递的数据量越少越好，因为这样可能降低耦合度
	6. 接口隔离原则 ISP, Interface Segregation Principle
		- 接口要小而专不要大而全，不强迫客户依赖于它们不用的方法
- 11:50 
	#编程 #设计模式
	# GoF 设计模式
	## 概念
	- 设计模式 Design Pattern 是被广泛接受的、可重复使用的软件设计中常见问题的**典型解决方案**，是在软件开发过程中对常见问题的反复实践和总结得出的经验和反思
	- GoF，Gang of Four 合作出版《Design Patterns: Elements of Reusable Object-Oriented Software》一书共收录 23 种设计模式，从此树立软件设计模式领域的里程碑，因此而得名
	- GoF 设计模式的三个类别
		1. 创建型模式：关注对象的创建机制，将**对象的创建和使用分离**；使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成
		2. 结构型模式：关注对象/类间的关系（结构），将类或对象按某种布局组合在一起形成更大的结构，并提供了简化设计的方式
		3. 行为型模式：关注对象之间的通信和算法的分配（怎样完成目标），描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务
	 
- 22:31 
	#驾考/科目三
	# 科目三
	## 考试项目
	1. 上车准备
		- 第 1 次：不用系安全带，听到“上车准备”后下车，逆时针绕行一周，按 4 个感应器
			- 从驾驶位开车门肯定要往后看安不安全（注意车门开启超过 10 s 算挂，如果后面有车来就关门，等下再下车），然后往你看的方向绕车走就行
			- 按钮按 2 s，确保正确响应
		- 第 2 次：回车确保关紧车门，调座椅、后视镜，**系好安全带**，检查灯光和挡位是否复位
			- 座椅可以稍微往后倾 👉 目光要看远方，坐得舒服
			- 挡位是在 P 档，手刹要拉起
	2. 灯光模拟
		- 不要抢语音，语音结束后要在 3 s 内做出操作 
		- 近光灯：==会车==、==跟车==、==有照明==
			1.  ？请开启灯光/前照灯
			2. （夜间）同方向近距离跟车
			3. （夜间）窄路/窄桥（与非机动车）会车
			4. （夜间）通过交通信号灯控制的路口
			5. （夜间）路口直行
			6. 夜间在照明良好的条件下行驶
		- 远光灯：==没有路灯==、==照明不良==
			1. 夜间在照明不良/没有路灯条件下行驶
		- 远近交替：==超车==、==通过==
			1.  夜间通过急弯/坡路/拱桥/人行横道/没有交通信号灯控制的路口
			2. 夜间超越前方车辆
		- 示廓灯+应急灯：==临时停车==、==故障==
			1. 路边临时停车 
	3. 起步
		- 观察左右后视镜
		- 打左转向灯（起码 3 s），鸣喇叭 2~3 次
		- 踩刹车，先换挡（D 档）再松手刹
	4. 左转弯
		- 先变道至左转车道（虚线时），
	5. 
		-  