
- 16:53 
	#编程/设计模式 
	# 抽象工厂模式 Abstract Factory
	## 前置信息
	- 产品族：指一组相互**关联或依赖**的系列产品对象，这些对象需要协同工作才能实现完整功能。是多个互不相同的关联产品的**水平**组合
	- 产品等级：指单个产品接口的**垂直**扩展，它们之间是继承关系
		举例：主板是抽象接口，它又被 Intel 主板和 AMD 主板继承，是一个等级；而主板+芯片组+CPU 在一起组合成一个 Intel 电脑，是产品族
		 ![[Pasted image 20250611155334.png]]
	## 抽象工厂结构
	- UML 类图：
		![[Pasted image 20250611155546.png]]
		- 客户端调用（通过）抽象工厂接口 `AbstractFactory` （定义了创建产品族的抽象方法），调用时实际需要具体工厂对象 `ConcreteFactory` （实现了具体创建产品族）作为参数，来决定是生产哪个具体的产品族
		- `ConcreteFactory1` 是具体工厂类，用于创建/使用具体的产品族 `ConcreteProductA1` 和 `ConcreteProductB1`
		-  `ProductA` 是抽象产品类，定义了产品 `A` 的公共接口，使同一产品等级的不同具体产品 `A` 类都可以实现相同的接口
			- `ConcreteProductA1` 和 `ConcreteProductA2` 是同一产品等级的具体产品类，用于实例化具体的产品
	- 代码实现：与上述不同的是多了类属性，以及把客户端调用写成一个类
	```python
	from abc import ABC, abstractmethod
	class AbstractFactory(ABC):
	    factory_name = ''
	    @abstractmethod
	    def create_ProductA(self):
	        pass
	    @abstractmethod
	    def create_ProductB(self):
	        pass
	
	class ConcreteFactory1(AbstractFactory):
	    factory_name = 'ConcreteFactory1'
	    def create_ProductA(self):
	        return ProductA1('1_series')
	    def create_ProductB(self):
	        return ProductB1('1_series')
	
	class ConcreteFactory2(AbstractFactory):
	    factory_name = 'ConcreteFactory2'
	    def create_ProductA(self):
	        return ProductA2('2_series')
	    def create_ProductB(self):
	        return ProductB2('2_series')
	    
	class ProductA(ABC):
	    series_name = ''
	    @abstractmethod
	    def use(self):
	        pass
	
	class ProductB(ABC):
	    series_name = ''
	    @abstractmethod
	    def use(self):
	        pass    
	
	class ProductA1(ProductA):
	    def __init__(self, series_name):
	        self.series_name = series_name
	    def use(self):
	        print("ProductA1")
	
	class ProductA2(ProductA):
	    def __init__(self, series_name):
	        self.series_name = series_name
	    def use(self):
	        print("ProductA2")
	
	class ProductB1(ProductB):
	    def __init__(self, series_name):
	        self.series_name = series_name
	    def use(self):
	        print("ProductB1")
	
	class ProductB2(ProductB):
	    def __init__(self, series_name):
	        self.series_name = series_name
	    def use(self):
	        print("ProductB2")
	
	class Client:  # 客户端调用接口，当然也可以直接通过函数来调用
	    def create_products(self, factory: AbstractFactory):
	        product_a = factory.create_ProductA()
	        product_b = factory.create_ProductB()
	        product_a.use()
	        product_b.use()
	        info = ''' -------- products created from [{}] info: -------
	        productA: {}
	        productB: {}
	
	------- End ------------
	        '''.format(factory.factory_name, product_a.series_name, product_b.series_name)
	        print(info)
	
	if __name__ == '__main__':
	    client = Client()
	    client.create_products(ConcreteFactory1())
	    client.create_products(ConcreteFactory2())        
	```
	## 对比
	- 工厂模式有多个工厂（抽象工厂+多个具体工厂），**一个**产品接口/抽象类（可理解为==**只有 1 个产品等级**==，何谈产品族），根据继承抽象工厂中的方法来多态创建具体产品对象
		- 如果业务增加，会使得系统中类的个数成倍增加，提高了代码的复杂度）（因为每个具体产品都需要一一对应的具体工厂类来生产）
	- 抽象工厂有多个工厂（抽象工厂+多个具体工厂），**多个**产品接口/抽象类（**有多个产品等级**），对产品子类进行分组，根据继承抽象工厂中的方法多态创建不同产品等级的产品对象的多个不同组合（即不同的产品族）
		- 因为分组，所以分组中的产品扩展就比较困难，需要同时修改 `AbstractFactory` ， `ConcreteFactory` ；而只是增加分组就比较容易，只用再新增一个具体共产类 