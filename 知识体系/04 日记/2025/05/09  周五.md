
- 09:23 
	#编程 #python 
	# 函数应用实战
	## 例 1：随机验证码
	- 设计一个生成随机验证码的函数，验证码由数字和英文大小写字母构成，长度可以通过参数设置
		```python
		import random
		import string
	
		ALL_CHARS = string.digits + string.ascii_letters
	
		def generate_code(*, code_len=4):
	    	return ''.join(random.choices(ALL_CHARS, k=code_len)) # 用‘’连接字符，即字符直接相连
		``` 
	- 思路：既然要随机生成 XX 组成的验证码，那直接**把所有 XX 弄到一个容器里，再多次从容器中随机抽取 X 就行**
		- `string.digits` 是 0-9 的字符串， `string.ascii_letters` 是所有大小写英文字母的字符串
		- `random` 模块的 `sample` 和 `choices` 都可随机抽样，前者是无放回（不重复）；后者是有放回（能重复）。2 个函数第一个参数代表抽样的总体，第二个 k 代表样本容量（命名关键字参数）（ `choice` 是单次随机抽样 ）。 `choices` 返回的是一个列表，其中元素是每次随机抽的样
		- **把列表中的元素组合成一个完整的 string，用字符串的 `join` 方法**
	## 例 2：判断素数
	- 设计一个判断给定的大于1的正整数是不是质数的函数
		```python
		def is_prime(num: int) -> bool:
	    	for i in range(2, int(num ** 0.5) + 1):
	        	if num % i == 0:
	            	return False
	    	return True
		``` 
		- `: int` 用来标注参数的类型，虽然它对代码的执行结果不产生任何影响，但是很好的增强了代码的可读性； `-> bool` 用来标注函数返回值的类型，它也不会对代码的执行结果产生影响
		- 1 个函数里  `return` **只会执行 1 次**（比如上面例 2 中 ` return False ` 后，就直接返回代码调用函数处了，不会再执行模块里的 `return True` ），类比 `break` 之于 for 循环（直接打破进程）
	## 例 3：最大公约数和最小公倍数
	- 设计计算两个正整数最大公约数和最小公倍数的函数
		```python
		def lcm(x: int, y: int) -> int:
	    	"""求最小公倍数"""
	    	return x * y / gcd(x, y)
	
		def gcd(x: int, y: int) -> int:
	    	"""求最大公约数"""
	    	while y % x != 0:
	        	x, y = y % x, x
	    	return x
		``` 
		- 函数之间可以相互调用，上面 `lcm` 函数就调用了 `gcd` 函数 
- 09:57 
	#编程 #python 
	# Python Day 16    函数使用进阶
	## 高阶函数
	- 把一个函数作为其他函数的参数或返回值的用法
		```python
		def calc(*args, **kwargs):  # 传入任意多个参数，实现求和操作
	    	items = list(args) + list(kwargs.values())
	    	result = 0
	    	for item in items:
	        	if type(item) in (int, float):
	            	result += item
	    	return result
		``` 
		- 如果不止想实现求和操作，而是更多自定义的运算（上面的代码只能求和是因为函数中使用了 `+=` 运算符，这使得函数跟加法运算形成了耦合关系），如果能解除这种耦合关系，函数的通用性和灵活性就会更好
		```python
		def calc(init_value, op_func, *args, **kwargs):  # 操作函数是参数
	    	items = list(args) + list(kwargs.values())
	    	result = init_value  # 初始值
	    	for item in items:
	        	if type(item) in (int, float):
	            	result = op_func(result, item)   #操作函数
	    	return result
		def add(x, y):
	    	return x + y
		def mul(x, y):
	    	return x * y
		
		print(calc(0, add, 1, 2, 3, 4, 5))  # 15
		print(calc(1, mul, 1, 2, 3, 4, 5))  # 120
		``` 
		- **调用函数需要在函数名后面跟上圆括号，而把函数作为参数时只需要函数名即可**
			- **函数名本身是一个变量**，指向内存中的函数对象； `()` 是函数调用的操作符，触发函数执行
			```python
		def greet():
	   		return "Hello, World!"
		print(greet)    # 输出：<function greet at 0x...> → 函数对象的引用
		print(greet())  # 输出：Hello, World! → 调用函数并获取返回值
			```
			- 传递函数时**传递的是函数对象本身**，不需要加 `()` 操作符来表示调用
	- **函数的无副作用设计**：调用函数除了产生返回值以外，不会对程序的状态或外部环境产生任何其他的影响
		```python
		old_strings = ['in', 'apple', 'zoo', 'waxberry', 'pear']
		new_strings = sorted(old_strings, key=len)
		print(new_strings)  # ['in', 'zoo', 'pear', 'apple', 'waxberry']
		``` 
		- （按照字符串长度排序）向 `sorted` 函数传入一个名为 `key` 的参数，将 `key` 参数赋值为获取字符串长度的函数 `len`
	## Lambda 函数
	- lambda 函数是没有的名字函数，其也叫做**匿名函数**
	- lambda 函数只能有一行代码，代码中的表达式产生的运算结果就是这个匿名函数的返回值
		```python
		old_nums = [35, 12, 8, 99, 60, 52]
		new_nums = list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, old_nums)))
		print(new_nums)  # [144, 64, 3600, 2704]
		``` 
		- lambda 即是**函数本身**，不用再专门定义 square 和 is_even 函数
		```python
		import functools
		import operator
		# 用一行代码实现计算阶乘的函数
		fac = lambda n: functools.reduce(operator.mul, range(2, n + 1), 1)
		# 用一行代码实现判断素数的函数
		is_prime = lambda x: all(map(lambda f: x % f, range(2, int(x ** 0.5) + 1)))
		# 调用Lambda函数
		print(fac(6))        # 720
		print(is_prime(37))  # True
		``` 
		- `all` 函数是 Python 内置函数，如果传入的序列中所有的布尔值都是 `True` ， `all` 函数返回 `True` ，否则 `all` 函数返回 `False` 
		- 函数是“一等函数”，**函数是可以直接赋值给变量的**
	## 偏函数
	- 指固定函数的某些参数，生成一个新的函数（类似数学里的偏导数），如此就无需在每次调用函数时都传递相同的参数
		```python
		import functools
		int2 = functools.partial(int, base=2)
		int8 = functools.partial(int, base=8)
		int16 = functools.partial(int, base=16)
		print(int('1001'))    # 1001
		print(int2('1001'))   # 9
		print(int8('1001'))   # 513
		print(int16('1001'))  # 4097
		``` 
		- `int`函数在默认情况下可以将字符串视为十进制整数进行类型转换，如果修改它的`base`参数，就可以定义出三个新函数，分别用于将二进制、八进制、十六进制字符串转换为整数 
- 16:08 
	#健身 #动作结构 
	# 健身动作详解
	## 坐姿划船
	- 大腿小腿夹角>90°：避免大腿过多参与 
		- 最好脚踩实，踩住踏板/（龙门架）垫子（不能发力时身体被往前拉）
	- 身体摆好姿势后，距离（指的把手后面的绳子长度）2 拳左右
		- 距离过远，腰椎压力大‘距离过近，每次放回是片砸
	- 身体角度比垂直后倾 15~20°（垂直时激活竖脊肌，不利于腰）
	- 胸椎中立位：极度挺胸（后倾），腰椎压力大
	- 手臂提前旋外，紧张背部肌肉
	- 把手高低差别：
		- 高（落点乳头稍下）：练上背
		- 低（落点肚脐）：练整背
	- 肩胛不同状态：
		- 肩胛内收带动：前提--好的肩胛控制能力
		- 肘关节向后压时肩胛保持外展状态：针对背阔肌
			- 肘不能超过背，不然背阔肌又被伸长
	- 节奏：向心适当加速（当然也不是爆发性加速），0.1~0.2 s 顶峰收缩，离心控制（离心时肌肉也有张力）
		- 拉类动作顶峰时也是阻力臂最大位置
		- 速度越慢需要的辅助/稳定肌群越多，更加费力
	## 罗马尼亚硬拉
	- 出杠时脚就站杠铃旁边（找个 Power Raft 放杠铃杆），不然可能力臂过大伤腰
	- 关注的点不是杠铃的上下移动，而是**骨盆的前后移动**
		- 髋关节铰链：骨盆位置 & 杠铃轨迹
	- 脊柱保持中立位
		- ==挺胸：想象锁骨向上挺起来==（而不是卧推那种肩胛往后拉），顺便帮助收紧背阔了
		- ==收紧臀肌：（在动作顶点）==确保脊柱底部也处于中立位
	- 杠铃贴近身体（不然阻力臂过大）
		- 贴近身体，主要是激活背阔肌
		- 小腿固定不要往后动，手放松
	- 前后重心在脚正中间，==**脚趾要抓地**==，构建足弓稳定性
	- 下落点放在膝盖左右位置（熟练了往下 2~3 cm）
	- 上下中心是髋关节（款铰链）
	- 起来时给点大腿外旋的力量