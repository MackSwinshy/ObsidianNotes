
- 09:49 
	#编程 #python 
	# Python Day 29 —— Python 发送邮件和短信
	## 发送电子邮件
	- 如果要发送电子邮件，需要使用 SMTP（简单邮件传输协议，不是 HTTP），它也是建立在 TCP 之上的应用级协议，规定了邮件的发送者如何跟邮件服务器进行通信的细节
	- Python 通过名为 `smtplib` 的模块将这些操作简化成了 `SMTP_SSL` 对象，通过该对象的 `login` 和 `send_mail` 方法，就能够完成发送邮件的操作
	```python
	import smtplib
	from email.header import Header
	from email.mime.multipart import MIMEMultipart
	from email.mime.text import MIMEText
	
	# 创建邮件主体对象
	email = MIMEMultipart()
	# 设置发件人、收件人和主题
	email['From'] = 'xxxxxxxxx@126.com'
	email['To'] = 'yyyyyy@qq.com;zzzzzz@1000phone.com'
	email['Subject'] = Header('上半年工作情况汇报', 'utf-8')
	# 添加邮件正文内容
	content = """据德国媒体报道，当地时间9日，德国火车司机工会成员进行了投票，
	定于当地时间10日起进行全国性罢工，货运交通方面的罢工已于当地时间10日19时开始。
	此后，从11日凌晨2时到13日凌晨2时，德国全国范围内的客运和铁路基础设施将进行48小时的罢工。"""
	email.attach(MIMEText(content, 'plain', 'utf-8'))
	
	# 创建SMTP_SSL对象（连接邮件服务器）
	smtp_obj = smtplib.SMTP_SSL('smtp.126.com', 465)
	# 通过用户名和授权码进行登录
	smtp_obj.login('xxxxxxxxx@126.com', '邮件服务器的授权码')
	# 发送邮件（发件人、收件人、邮件内容（字符串））
	smtp_obj.sendmail(
	    'xxxxxxxxx@126.com',
	    ['yyyyyy@qq.com', 'zzzzzz@1000phone.com'],
	    email.as_string()
	)
	```
	- 如果要发送带有附件的邮件，只需要将附件的内容处理成 BASE64 编码，那么它就和普通的文本内容几乎没有什么区别
	## 发送短信
	- 通过 `requests` 库向平台提供的短信网关发起一个 HTTP 请求，通过将接收短信的手机号和短信内容作为参数，就可以发送短信，代码如下所示
	```python
	import random
	import requests
	
	def send_message_by_luosimao(tel, message):
	    """发送短信（调用螺丝帽短信网关）"""
	    resp = requests.post(
	        url='http://sms-api.luosimao.com/v1/send.json',
	        auth=('api', 'key-注册成功后平台分配的KEY'),
	        data={
	            'mobile': tel,
	            'message': message
	        },
	        timeout=10,
	        verify=False
	    )
	    return resp.json()
	
	
	def gen_mobile_code(length=6):
	    """生成指定长度的手机验证码"""
	    return ''.join(random.choices('0123456789', k=length))
	
	
	def main():
	    code = gen_mobile_code()
	    message = f'您的短信验证码是{code}，打死也不能告诉别人哟！【Python小课】'
	    print(send_message_by_luosimao('13500112233', message))
	
	
	if __name__ == '__main__':
	    main()
	```
	 
- 14:10 
	#编程 #python 
	# Python Day 30 —— 正则表达式的应用
	## 正则表达式相关知识
	- 正则表达式 Regular Expression，是用来查找/匹配特定字符串模式的规则
	- 元字符：具有特殊功能的保留字符（不是转义字符，比如 `\d` 把它看作一个整体的元字符，而不是转义字符 ）
		 1. `.` 匹配任意字符
		 2. `\w` 匹配字母/数字/下划线/汉字
		 3. `\s` 匹配空白字符（包括\r, \n, \t）
		 4. `\d` 匹配数字
		 5. `\b` 匹配单词的边界
		 6. `^` 匹配字符串的开始
		 7. `14:10  匹配字符串的结束
		 8. `\W` （反义）匹配非字母/数字/下划线/汉字
		 9. `\S` （反义）匹配非空白字符
		 10. `\D` （反义）匹配非数字
		 11. `\B` （反义）匹配非单词边界
		 12. `[]` 匹配来自字符集的任意单一字符
		 13. `[^]` （反义）匹配不在字符集中的任意单一字符
		 14. `*` 重复 0 或多次
		 15. `+` 重复 1 或多次
		 16. `?` 重复 0 或 1 次
		 17. `{M}` 重复 M 次
		 18. `{M,}` 重复至少 M 次
		 19. `{M,N}` 重复至少 M 次，至多 N 次
		 20. `|` 分支
		 21. `(?#comment)` 注释
		 22. `(exp)` 匹配 exp 并捕获到自动命名的组中
		 23. `(?<name>exp)` 匹配 exp 并捕获到名为 name 的组中
		 24. `(?=exp)` （零宽断言）匹配 exp 前面的字符
		 25. `(?<=exp)` （零宽断言）匹配 exp 后面的字符
		 26. `(?!exp)` （负向零宽断言）匹配后面不是 exp 的字符
		 27. `(?<!exp)` （负向零宽断言）匹配前面不是 exp 的字符
		 28. `?` 懒惰匹配（写在后面）
		 29. `\` 转义处理特殊字符匹配
	- 详细参考 [正则表达式30分钟入门教程](https://deerchao.cn/tutorials/regex/regex.htm)
	## Python 对正则表达式的支持
	- Python 提供了 `re` 模块来支持正则表达式相关操作
	- `re` 模块中的核心函数：
		1.  `compile(pattern,flags=0)` ：编译正则表达式，返回正则表达式对象
		2. `match(pattern,string,flags=0)` ：用正则表达式匹配字符串，成果返回匹配对象，否则返回 `None`
		3. `search(pattern,string,flags=0)` ：搜索字符串中第一次出现正则表达式的模式，成功返回匹配对象
		4. `split(pattern,string,maxsplit=0,flags=0)` ：用正则表达式指定的模式拆分字符串，返回列表
		5. `sub(pattern,repl,string,count=0,flags=0)` ：用指定的字符串替换原字符串中与正则表达式匹配的模式，可以用 `count` 指定替换的次数
		6. `fullmatch(pattern,string,flags=0)` ： `match` 函数的完全匹配版本
		7. `findall(pattern,string,flags=0)` ：查找字符串所有与正则表达式匹配的模式，返回字符串的列表
		8. `finditer(pattern,string,flags=0)` ：查找字符串所有与正则表达式匹配的模式，返回一个迭代器
		9. `purge()` ：清除隐式编译的正则表达式的缓存
		10. `re.I` / `re.IGNORECASE` ：忽略大小写匹配标记
		11. `re.M` / `MULTILINE` 多行匹配标记
	## Python 中对正则表达式的使用
	1. 例一：验证输入用户名和QQ号是否有效并给出对应的提示信息
		-  要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0
		```python
	 	import re
	 
	 	username = input('请输入用户名: ')
	 	qq = input('请输入QQ号: ')  # 输入的是字符串
	 	# match函数的第一个参数是正则表达式字符串或正则表达式对象
	 	# match函数的第二个参数是要跟正则表达式做匹配的字符串对象
	 	m1 = re.match(r'^[0-9a-zA-Z_]{6,20}, username)  # 原始字符串
	 	if not m1:
	     	print('请输入有效的用户名.')
	 	# fullmatch函数要求字符串和正则表达式完全匹配
	 	# 所以正则表达式没有写起始符和结束符
	 	m2 = re.fullmatch(r'[1-9]\d{4,11}', qq)
	 	if not m2:
	     	print('请输入有效的QQ号.')
	 	if m1 and m2:
	     	print('你输入的信息是有效的!')
		```
		- 正则表达式是字符串匹配比较，所以输入 QQ 号不用再用 `int` 函数把它转化
		- 正则表达式字符串是**原始字符串**（前面加上 `r` ），字符串中没有所谓的转义字符，否则需要将反斜杠写作 `\\` ，表示数字的 `\d` 得书写成 `\\d`
			- 因为 python 解释器处理过程中会默认将 `\` 去掉，只保留后面的内容，除非是原始字符串
			- 具体流程是 python 解释器对字符串解析处理后存储为实际字符，再被正则引擎解析为元字符，所以想要正则表达式匹配特殊字符（如. / \*）就算是原始字符串也要写成 `r'\. \\ \*'` 才能被正则引擎理解（如果没 `r` 传给正则引擎的就只是 `'. \ *'` 错误 ）
			 ![[底层原理.png]]
		- 之所以 `m1` 写成  `r'^[0-9a-zA-Z_]{6,20}` 而不是 `r'^\w{6,20}14:10  是因为 `\w` 还能匹配中文汉字字符，不符合要求
		- 对 `if not m1` 详解：首先明确 `m1` 是 match 函数返回的 match 对象，其次进行 bool 判断时不是看 m1 是不是 bool 值，而是有对象存在本身就是 `True` ，没有对象（空）就是 `False`
		- `fullmatch` 函数要求字符串和正则表达式完全匹配，所以正则表达式没有写起始符和结束符
	 
	2. 例二：从一段文字中提取出国内手机号码
		```python
		import re
	 
	 	# 创建正则表达式对象，使用了前瞻和回顾来保证手机号前后不应该再出现数字
	 	pattern = re.compile(r'(?<=\D)1[34578]\d{9}(?=\D)')
	 	sentence = '''重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，
	 	不是15600998765，也不是110或119，王大锤的手机号才是15600998765。'''
	 	# 方法一：查找所有匹配并保存到一个列表中
	 	tels_list = re.findall(pattern, sentence)
	 	for tel in tels_list:
	     	print(tel)
	 
	 	# 方法二：通过迭代器取出匹配对象并获得匹配的内容
	 	for temp in pattern.finditer(sentence):
	     	print(temp.group()) # 返回temp对应的匹配字符串
	 
	 	# 方法三：通过search函数指定搜索位置找出所有匹配
	 	m = pattern.search(sentence)
	 	while m:
	     	print(m.group())
	     	m = pattern.search(sentence, m.end())
		```
		- 匹配对象（Match Object）的 `group(arg=0)` 方法是返回对应 arg 值组号的分组
			- 分组/子表达式（用 `()` ）来指定，指定同时每个分组会自动拥有一个组号，规则是从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推（分组 0 对应整个匹配字符串）
			- 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配
			- 可以使用 `(?:exp)` 这样的语法来剥夺一个分组对组号分配的参与权
	3. 例三：替换字符串中的不良内容
	```python
	import re
	
	sentence = 'Oh, shit! 你是傻逼吗? Fuck you.'
	purified = re.sub('fuck|shit|[傻煞沙][比笔逼叉缺吊碉雕]',
	                  '*', sentence, flags=re.IGNORECASE)
	print(purified)  # Oh, *! 你是*吗? * you.
	```
	- `flags` 参数代表了正则表达式的匹配标记,，如果需要指定多个值，用**按位或运算符**进行叠加，例如`flags=re.I | re.M`
	
	4. 例四： 拆分长字符串
	```python
	import re
	
	poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。'
	sentences_list = re.split(r'[，。]', poem)  # 列表中有''（空）
	sentences_list = [sentence for sentence in sentences_list if sentence]
	for sentence in sentences_list:
	    print(sentence)
	```
	-  `re.split()` 在处理分隔符时会切割并保留分隔符前后的内容，所以当遇到末尾分隔符时其后的空内容会被保留 
- 15:10 
	#健身 #凯圣王训练营 
	# 一年级第 10 天 —— 热量、推日热身、硬拉
	## 饮食结构
	1. 增肌减脂与热量的关系
		- 肌肉生长：身体的应激原理（肌肉的撕裂重组、超量恢复）
			- 前期/短期即使热量少，只要满足在适当时间，去触发体内合成代谢激素，补充糖原/蛋白以修复肌肉；可以满足增肌（适应周期）
	## 身体结果
	1. 推日热身
		- 外展
		- 擦玻璃（贴墙激活前锯肌）—— 前锯肌帮助稳定肩膀
		- 大臂水平内收（找胸肌募集感觉）
		- 开胸椎
	## 动作结构
	1. 硬拉的动作价值：后侧链整体参与，锻炼募集感、神经适应、整体力量、后侧链联动性
		- 硬拉阻力最大点是最低点（刚开始启动），要有稳定性、上身刚性、联动，容易受伤
	2. 罗马尼亚硬拉动作详解
		-  肩胛收紧，保持上背刚性
		- 髋关节为轴：主要是臀大肌和蹬膝的力量，上背部/竖脊肌是稳定 
- 15:45 
	#健身 #凯圣王训练营 
	# 一年级第 11 天 —— 碳水与血糖、肩胛骨肩关节
	## 饮食结构
	1. 碳水与血糖的关系：血糖波动（GL, GI）
		- 碳水在身体内储存的量远少于脂肪（糖原集中供能情况下 1~2 h 耗尽）
		- 外界摄入碳水→血糖波动大→分泌胰岛素（强合成代谢激素）
		- GI（Glycemic Index，升糖指数，==质==）， $GI=\frac{含有50g碳水化合物某食物的2h血糖应答}{50g葡萄糖的2h血糖应答}*100$  
			- 公式中的 50 g 碳水化合物为**纯**碳水
			- 不迷信低 GI 饮食，容易营养不良，或者对训练提高不利
		- GL（Glycemic Load，血糖负荷，==量==）， $GL=\frac{碳水化合物含量(g)}{100}*GI$
			- GL<10 几乎不波动，GL 取10~15 时有一定波动，GL>20 剧烈波动
	## 身体结构
	1. 肩胛骨控制训练（基本功）
		-  借助拉力带，双手掌心向下握住拉力带各一端，做肩胛内收的动作
	2. 肩关节活动度训练 （基本功）
		-  白蜡杆开肩 /绕肩
		![[Pasted image 20250525154415.png]]
		 
		- 拉力带往后拉伸肩
		![[Pasted image 20250525154444.png]]
		 
		
	
	 
- 17:23 
	#健身 #动作结构 
	# V 把/对握高位下拉
	- 握：半握（握中间），把手扣过去（手腕稍微向里侧屈）固定住 → 减少手腕发力
	- 肘：夹肘，不要开肘（底端大臂贴躯干）
	- 胸：不过分挺胸，甚至稍微含胸 → 锻炼背阔肌
		- 背阔肌有个功能是大臂后伸
	- 躯干：微微后仰
	- 离心：强度大，不能开肘
	- 呼吸
		- 离心吸气涨胸（胸式呼吸）→ 加上含胸，让肩胛更好贴合在胸廓上
		- 呼气时挤压声门/鼻子呼气也行（类似嘶\~\~，Emm\~\~）→ 维持腹内压
	- 肩胛：功能不好情况，底端肩胛容容易被翘（本来是肩胛下降+下回旋），但是**内收很少**
	- 想象：把肘部往下压 
- 18:32 
	#健身 #动作结构 
	# 杠铃划船
	- 重心：底端手离膝盖 1.5~2 拳
		- 向前 →  腰部压力大，容易腰酸
		- 向后 → 斜方肌发力比背多
	- 肩胛：肩胛**内收**（启动动作）+**下降**
	- 轨迹
		- 杠铃沿大腿朝髋动 → 大臂后伸，收紧背阔肌，
		- 肩也往后平移 → 如果肘在往后动，肩固定，则肩膀容易前旋，被撬起来，背被拉长
	- 想象：肘部往屁股靠 → 肩胛的内收+下降 （动作过程中肘部是无法超过背部往后伸的）
	- 速度：启动时较快速度（不是爆发）→ 练背一般阻力臂最大在底端（启动时），慢慢来顶峰收缩不易 