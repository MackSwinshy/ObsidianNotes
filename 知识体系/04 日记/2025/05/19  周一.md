
- 09:42 
	#编程 #python 
	# Python Day 22 —— 对象的序列化和反序列化
	## JSON 概述
	- JSON 是 Javascript Object Notation 的缩写，它结构紧凑而且是纯文本，能用于**跨语言跨平台的数据交换**。目前JSON基本上已经取代了XML（可扩展标记语言）作为**异构系统间交换数据的事实标准**（跨语言兼容、数据持久化、结构化传输（强制要求键名用双引号）、安全性高）
	- 应用场景：
		- **API 接口**：如 HTTP 接口返回 JSON 数据，前端（JavaScript）和后端（Python）均可直接解析
		- **配置文件**：如 `package.json`（Node.js）或 `settings.json`（VS Code）使用 JSON 格式
	```json
	{
	    name: "骆昊",
	    age: 40,
	    friends: ["王大锤", "白元芳"],
	    cars: [
	        {"brand": "BMW", "max_speed": 240},
	        {"brand": "Benz", "max_speed": 280},
	        {"brand": "Audi", "max_speed": 280}
	    ]
	}
	```
	- JSON与Python中的字典非常类似而且支持嵌套结构
	## 读写 JSON 格式的数据
	- 在Python中，如果需要用到JSON格式，相关操作可以使用 `json` 模块中的函数
		- `dump` - 将 Python 对象按照 JSON 格式序列化到文件中
		- `dumps` - 将 Python 对象处理成 JSON 格式的字符串
		- `load` - 将文件中的 JSON 数据反序列化成对象
		- `loads` - 将字符串的内容反序列化成 Python 对象
	```python
	import json
	my_dict = {
	    'name': '骆昊',
	    'age': 40,
	    'friends': ['王大锤', '白元芳']
	}
	print(json.dumps(my_dict))  # 输出里的中文字符都是用Unicode编码：{"name": "\u9a86\u660a"
	with open('data.json', 'w') as file:
	    json.dump(my_dict, file)
	with open('data.json', 'r') as file:
	    my_dict = json.load(file)
	    print(type(my_dict))
	    print(my_dict)
	```
	
	- ==序列化 serialization==：指将数据结构或对象状态转换为可以存储或传输的形式，在之后能恢复原先状态的过程。而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化
	## 使用网络 API 获取数据
	- 绝大多数的网络数据服务（或称之为网络API）都是基于 [HTTP](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE) 或HTTPS提供JSON格式的数据
		- 我们可以通过Python程序发送HTTP请求给指定的URL（统一资源定位符），这个URL就是所谓的网络API，如果请求成功，它会返回HTTP响应，而HTTP响应的消息体中就有我们需要的JSON格式的数据
	```python
	import requests   # 第三方库，通过URL接入网络
	
	resp = requests.get('http://api.tianapi.com/guonei/?key=APIKey&num=10') # API
	if resp.status_code == 200:  # HTTP响应状态码
	    data_model = resp.json()   # 将返回的JSON格式处理成Python字典
	    for news in data_model['newslist']:
	        print(news['title'])
	        print(news['url'])
	        print('-' * 60)
	```
- 10:59 
	#编程 
	# HTTP 协议入门
	- HTTP 即超文本传输协议（HyperText Transfer Protocol），是客户端（如浏览器）和服务器（如万维网）之间传输数据（HTML 文档、图片、视频）的规则，是 Web 上进行任何数据交换的基础
		- 超文本 = 超链接 + 文本，即包含可点击链接的文本
	- 客户端与服务器之间通过交换一个个独立的消息（而非数据流）进行通信（请求 request 与响应 response）
		- 每个请求都会被发送到一个服务器，它会处理这个请求并提供一个称作响应的回复
		- 这些消息包括 HTML 文档（描述该页面内容）、可执行脚本、CSS（布局信息）、图片和视频等，最后客户端根据这些消息渲染页面，展示给用户
		- HTTP 请求/响应的步骤：
			1.  客户端连接到服务器：与服务器端口建立 1 个 TCP 连接
			2.  发送 HTTP 请求：通过 TCP 连接客户端发送一个文本的请求报文
			3.  服务器接受请求并返回 HTTP 响应：服务器解析请求，定位请求资源，将资源复本写到 TCP 连接中，有客户端读取
			4.  释放 TCP 连接
			5. 客户端浏览器解析 HTML 内容，渲染页面
	- **TCP** 协议：传输控制协议 Transmission Control Protocol，核心功能是数据的可靠传输与面向连接（通讯前需要先建立连接，结束后释放连接）
		- HTTP（应用层）是基于 TCP 连接（传输层）的（TCP 的可靠传输机制符合 HTTP 要求）
	- **HTML**：是超文本标记语言（Hyper Text Markup Language），用于描述网页结构和内容
		- 当浏览器通过 HTTP 请求一个网页（如 `http://example.com/index.html` ），服务器返回 HTML 文档作为响应内容
	- **URL**地址：是统一资源定位符（Uniform Resource Locator），即网址，用于定位互联网上的资源
		- 结构示例： `http://www.example.com:80/path/to/page?param=value#section`
			- **协议**： `http` （指定使用 HTTP 协议，https 多了保密）
			- **域名**： `www.example.com` （服务器的地址）
			- **端口**： `:80` （HTTP 默认端口，可省略）
			- **路径**： `/path/to/page` （资源在服务器上的位置，一个目录或者文件地址）
			- **参数**： `?param=value` （附加查询条件）
			- **锚点**： `#section` （页面内的定位点）
- 13:04 
	#编程 #python #具体函数
	# Python 常用内置高阶函数
	- 高阶函数：一个函数的参数/返回值是另一个函数的函数
	1. `map(function,iterable)` 函数： **映射**功能，让可迭代对象（如列表）中每个元素都完成一次对函数的调用
		![[Pasted image 20250519123406.png]]
		- `map` 返回值是一个迭代器对象（map object），**直接 print 不会输出，需要 `list(map())` 后才能输出列表**
		- `map` 经常与匿名函数 `lambda` 联合使用
	2. `filter(function,iterable)` 函数：**过滤**功能，在函数中设定过滤条件，逐一循环迭代器中的元素，将返回值为True时的元素留下，返回一个filter 迭代器对象（filter object）
		![[Pasted image 20250519124237.png]]
		- 这个函数的返回值应该是 bool ，这样才有意义
		- 图中的函数写错了，应该是 `lambda x:x.islower()` ，否则返回的是 `['Littlefive','amanda','hellokity']` （没起到过滤的作用）
	3.  `reduce(function,iterable,initial_value)` 函数：**归约**功能，顾名思义就是减少，把函数作用在可迭代对象上，**这个函数必须接收两个参数**（否则没法归约），reduce把结果继续和序列的下一个元素做累积计算，直到最后缩减为单个数，其**返回值为一个值（而不是对象）**
		- 常用于叠加、叠乘等
		 ![[Pasted image 20250519125125.png]]
		 - 该函数需要从模块中导入 `from functools import reduce`
	4. `sorted(iterable,key=None,reverse=False)` 函数：**排序**功能，对所有可迭代的对象进行排序操作
		- `key` ： 用来进行比较的元素，可以是函数，该函数的参数就是可迭代对象中的成员，通过函数的返回值进行比较
		- `reverse` ：True 是降序，False 是升序
		- `sort` 是应用在类 `list` 的方法，无返回值（对原列表进行操作）；而 `sorted` 应用在所有可迭代对象上，返回一个新的 list
- 15:25 
	#驾考 
	# 科目二部分项目
	## 曲线行驶/ S 弯
	- 领线法：车头视线点一直扫着线走
		- （左大灯代表左车头）参照点在挡风玻璃上离 A 柱一拳左右，记为 L 点；（右大灯代表右车头）参照点在挡风玻璃右 $\frac{1}{3}$ 处，记为 R 点（本质上还是因为车内看不到左、右大灯的代替参照点，具体位置还需要根据实际情况调整）
		- 对着入口正中进入，往前走，当 L 点与前边黄线（右线）相交，方向盘向左**打一圈**（+45°？），让L 点扫线走，一段弯过后，L 点离开右黄线，当 L 点与左黄线相交，方向盘回正，继续往前，当 R 点与前黄线（左）相交时，方向盘向右**打一圈**，让 R 点扫线走
		- 与黄线距离还可以参照后视镜：（后视镜中）车身与黄线距离 2~3 指宽即可（微调方向时别修太猛，转 90°就行，即左/右手上举）
	- 正中进入入口方法：
		- 沿着直线行驶，当 A 柱左边（左侧车窗）看见边线，方向盘往左打一圈，当挡风玻璃左夹角对上左边线（或者方向盘 12 点钟方向在路中间偏左点），然后回正
	## 侧方位停车：
	- 在倒车前，往前开的过程中注意调微调车身与右边线距离（30~50 cm 为宜）
		- 左雨刮器最高点沿着右边线走就行
		- 或者右后视镜中，车身与边线相距 1 指左右
	- 倒车时的几个点位：
		1. （右后视镜）前库角出现在上下一半的位置时，可以开始倒车
		2. 倒车，当前库角在右后视镜中刚刚消失时，方向盘往右打死
		3. 看左侧后视镜，当最里面库角出现时，方向盘回正
		4. 继续倒车，左后轮快要压到黄虚线时，方向盘往左打死
		5. 车身与库线平行后（两边后视镜都要看），停车，**方向盘不动**
	- 出库时的几个点位：
		1. 往前开（此时方向盘是往左打死），当左雨刮器最高点与左边线相交时，方向盘回正
		2.  往前（只开很短），雨刮器最高点超过边线（具体就是关节点右边在黄边线左侧了），方向盘往右打一圈
		3. 车正后，回正方向
	 - 微调（**边线宽了**）：提前往右边打满（不再是前库角消失，而是前库角还有一点角在时）
	 - 多线程操作：例如打转向灯、换挡时（侧方位停车入库后停车时），需要操作一侧的手离开方向盘进行操作，另外一只手把住方向盘
	## 直角转弯
	- 提前注意微调车身与右边线距离：~30 cm
		- 左侧雨刮器制高点沿右边线走
		- 方向盘 12 点钟方向正对路中间
		- 右后视镜中车身与边线距离 1 指宽左右
	- 点位：
		1. 提前开左转向灯
		2. 往前开，当车内（就是驾驶员旁边的）把手后侧与横着黄边线对齐后，方向盘往左打死 