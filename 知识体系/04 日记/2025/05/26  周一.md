
- 15:55 
	#编程 #python 
	# Python Day 31 —— Python 语言进阶
	## 重要知识点
	1. 生成式（推导式）的用法
	2. 嵌套列表
		```python
		names = ['关羽', '张飞', '赵云', '马超', '黄忠']
		courses = ['语文', '数学', '英语']
		# 录入五个学生三门课程的成绩
		# 错误 - 参考http://pythontutor.com/visualize.html#mode=edit
		# scores = [[None] * len(courses)] * len(names)
		scores = [[None] * len(courses) for _ in range(len(names))] # 前面得到[None,None,None]
		for row, name in enumerate(names):
	    	for col, course in enumerate(courses):
	        	scores[row][col] = float(input(f'请输入{name}的{course}成绩: '))
	        	print(scores)
		```
		- `None` 是 Python 中的特殊常量，表示空值， `[None]` 就是只有一个成员为空值的列表
		- ==用列表生成式的原因==：创建独立的嵌套列表（列表的每个子列表成员都是独立的），而乘法操作本质上是**复制同一个子列表的引用**（列表的每个子列表成员是关联的，当修改其中一个子列表时，所有其他子列表也会被修改，因为它们指向同一个对象）
			- 列表推导式每次迭代都会创建新的列表对象，而乘法操作符 * 会复制引用，导致嵌套列表中的子列表共享内存空间
	3. `heapq` 模块（堆排序）
		```python
		"""
		从列表中找出最大的或最小的N个元素
		堆结构(大根堆/小根堆)
		"""
		import heapq
	
		list1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92]
		list2 = [
	   		{'name': 'IBM', 'shares': 100, 'price': 91.1},
	   	 	{'name': 'AAPL', 'shares': 50, 'price': 543.22},
	    	{'name': 'FB', 'shares': 200, 'price': 21.09},
	    	{'name': 'HPQ', 'shares': 35, 'price': 31.75},
	    	{'name': 'YHOO', 'shares': 45, 'price': 16.35},
	    	{'name': 'ACME', 'shares': 75, 'price': 115.65}
		]
		print(heapq.nlargest(3, list1))
		print(heapq.nsmallest(3, list1))
		print(heapq.nlargest(2, list2, key=lambda x: x['price']))
		print(heapq.nlargest(2, list2, key=lambda x: x['shares']))
		```
	4. `itertools` 模块：迭代工具
	5. `collections` 模块：额外的工具类
		- `namedtuple` 命令元组
		- `deque` 双端队列（Python中的列表底层是基于数组来实现的，而deque底层是双向链表）
		- `Counter` ： `dict` 的子类，键是元素，值是元素的计数
		- `OrderedDict` ： `dict` 的子类，它记录了键值对插入的顺序，看起来既有字典的行为，也有链表的行为
		- `defaultdict` ：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值
	## 数据结构和算法
	- 算法 Algorithm：解决问题的**方法和步骤**，是**抽象的逻辑流程**，与具体编程语言无关，有确定的执行步骤，明确的输入输出要求
		- 代码可以看作是**算法的具体语言实现**
		- 脚本是用于自动化任务的**短小代码集合**
	- 详细内容参见算法相关知识
	## 函数的使用方式
	- 将函数视为“一等公民”
		- 函数可以赋值给变量
		- 函数可以作为函数的参数
		- 函数可以作为函数的返回值
	- 高阶函数的用法（ `filter` 、 `map` 、 `reduce` ）
	- 位置参数、可变参数、关键字参数、命名关键字参数
	- 参数的元信息（增加代码可读性）：储存在函数的 `__annotations__` 内置属性中
	```python
	def add(x:int, y:int) -> int:
		return x + y
	```
	- 匿名函数和内联函数的用法（就是 `lambda` 函数）： `:` 之前是参数， `:` 之后是返回值
	- **作用域**详解
		- python 区分作用域的目标是能够**复用变量名**，不用担心与全局变量、其他函数中的变量冲突
			- **变量**：变量本质是**指向对象的引用**（相当于给对象添加一个标签），而**对象是数据的实体**，是内存块（包含地址、类型、值），而变量仅储存对象的内存地址
			- 赋值操作的本质就是给对象添加一个标签
			- 不可变对象（ `int` , `str` , `tuple` ）修改时只能创建新对象，而可变对象（ `list` , `dict` , `set` ）可修改内容
			- 参数传递：本质上是一种赋值操作。对于不可变对象，函数内修改会创建新对象，不影响原始变量；可变对象的函数内修改会直接影响原始对象
		 ```python
	      x = 10
	      y = x
	      x += 5  # int是不可变对象，创建新对象15，y仍指向10
	      print(x, y)  # 15, 10 
	      # 参数传递
	      def modify(num, list):  # 参数num接收n的值（10），num也指向10的引用，list接收m的引用
	      num += 1    # 创建新int对象（11），原始n不受影响，是num变量再进行操作，与原来n变量无关
	      list.append(5)  # 直接修改原列表对象
	  
	  	  n = 10
	  	  m = [1,2,3,4]
	      modify(n, m)
	      print(n, m)  # 输出：10 [1,2,3,4,5]
		  ```
		- 作用域定义：是程序中定义变量和函数的区域，它规定了这些名称在代码中的可见范围（在不同的作用域中，相同名称的变量或函数可以代表不同的对象）
			- 变量的作用域取决于其**定义位置**，变量也是在定义时才赋值（给对象标签的）
		- 不同类型的作用域：
			1. 局部作用域 Local Scope ：在**函数内部**定义的作用域，函数外部无法直接访问这些局部变量
			2. 嵌套/闭包作用域 Enclosing/Embedded Scope：当一个函数嵌套在另一个函数内部时，内部函数可以访问外部函数的变量，此时**外部**函数的作用域就是嵌套作用域
			3. 全局作用域 Global Scope：在**模块（文件）** 级别定义的作用域，可以在整个模块的任何地方访问
			4. 内置作用域 Built-in Scope：是 Python 解释器自带的作用域，包含了所有内置的函数和异常类型，可以在任何地方都可以直接使用
		-  变量查找规则：LEGB 顺序（局部->嵌套->全局->内置），本质上是在本地空间寻找不到的变量，逐级向上级寻找
		- `global` 语句用于在**函数内部**声明一个变量为全局变量（在函数外部也不需要，因为本来就是了），这样在函数内部就可以对全局变量进行修改
		```python
		global_variable = 50  # 1. 初始化全局变量
	 
	 	def modify_global():  # 2. 定义函数（仅创建函数对象，不执行函数体）
	     	global global_variable
	     	global_variable = 60  # 赋值语句存在于函数体但尚未执行
	     	
	 	print(global_variable)  # 3. 输出初始值 50 ➔ 50
	 	modify_global()         # 4. 调用函数 ➔ 此时才执行函数体内的赋值操作
	 	print(global_variable)  # 5. 输出修改后的值 ➔ 60
		```
		- ==函数定义（def语句）只是创建函数对象，不会执行函数体内的代码；只有调用时函数体的代码才会执行==
		- `nonlocal` 语句用于在嵌套函数（内部函数）中声明一个变量为外层（非全局）函数的变量，从而可以在内部函数中修改外层函数的变量
		```python
		def outer():
	    	enclosing_variable = 70
	    	def inner():
	        	nonlocal enclosing_variable
	        	enclosing_variable = 80
	    	inner()
	    	print(enclosing_variable)
	    	
	  	outer()  # 输出: 80
		``` 
	- 闭包 Closure
		- 本质： 闭包=内部函数+引用环境(lexical  environment)，该环境包括函数创建时可见的所有非全局变量
		- 目的：通过闭包/嵌套函数这种形式，在不使用全局变量的情况下，保留状态。如果状态（例如技术 count）放在内部函数内，就是一个局部变量，每次调用之后都要被销毁（参照下面代码例子）
		```python
		def outer_func(func):
	    count=1 # 想要保存的状态，如果count放在inner_func中，每次调用都会使得count重新初始化，每次刷新何来保存状态
	    def inner_func(*args,**kwargs):
	        nonlocal count
	        print(f'第{count}次调用')
	        count+=1
	        return func(*args,**kwargs)
	    return inner_func
		``` 
		- 原理：
			1.  作用域链： `inner_func -> outer_func的局部作用域 -> 全局作用域` ，实现对外部变量的引用
			2. `__closure__` 属性：闭包（内部函数）保存状态的原理是通过闭包的 `__closure__` 属性的 `cell` 对象来储存被捕获的外部变量。因此即使删除了原本的外部函数对象，仍然可以调用闭包实例
			3. 内存隔离：每个闭包实例都会创建独立的作用域链环境（ 每次 `cell` 对象的地址都是新建的 ），独立互不干扰
	
	- 装饰器
		- 本质：是**修改/增强其他函数行为**的函数（闭包则主要是为了保存状态），能够使用 `@` 语法糖简化调用
		- 特征：接收函数为参数，是嵌套函数形式，返回增强后的函数
			- 思辨：为什么要用嵌套函数？想要实现新功能也可以重新定义一个新函数 `def new_func(func,*arg,**kwarg)...` ，但这样每次调用都需要手动传递函数和参数，而装饰器直接通过语法糖就可自动应用，保持了前后函数调用方式的一致性
	## 面向对象相关知识
	- 三大支柱：封装、继承、多态
- 18:50 
	#健身 #凯圣王训练营 
	# 一年级第 12 天 —— FFMI、真空腹、差值，5-5
	## 饮食结构
	1. FFMI：去脂体重指数，Fat Free Mass Index，是衡量人体肌肉质量的指标，专注于瘦体重（肌肉、骨骼、水分）
		- $FFMI=\frac{体重(kg)*(1-体脂率)}{身高(m)^2}$ 
		- 用瘦体重衡量自己的进步
	## 动作结构
	1. 腹横肌
		-  真空腹：锻炼腹横肌（要放松腹直肌）
	2. 美学：肩腰差、胸腰差、头肩比
	## 周期结构
	1. 5\*5 计划的原理：锻炼白肌纤维（与肌耐力无关），适合 IIb 型肌纤维生长，以及神经适应性 