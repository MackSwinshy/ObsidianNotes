---
创建时间: 2025/05/05 09:26
上次编辑时间: 2025/07/06 11:07
---

- 09:26 
	#编程 #python 
	# Python Day 11    数据结构——字符串
	## 字符串的定义
	- 字符串就是**由零个或多个字符组成的有限序列**
	- 转义字符：用 `\` （反斜杠）来表示转义，'转义'即后面的字符不再是它原来的意义
	- 原始字符串：以 `r` 或 `R` 开头的字符串，是字符串中的每个字符都是它本来的含义，没有所谓的转义字符
		- 例如，在字符串 `'hello\n'` 中， `\n` 表示换行；而在 `r'hello\n'` 中， `\n` 不再表示换行，就是字符 `\` 和字符 `n`
	- 字符的特殊表示：在 `\` 后面还可以跟一个八进制或者十六进制数（\uUnicode 也可）来表示字符
	## 字符串的运算
	- 拼接（+）、重复（\*)
	- 比较运算：因为字符串在计算机内存中也是以二进制形式存在的，那么字符串的大小比较比的是**每个字符对应的编码的大小**（一位一位顺序进行比较直到分出大小）
		- 可以用 ord 函数得到单个字符对应编码
	- 成员运算（in 和 not in），获取长度（len 函数）
	- 索引和切片：几乎同，但注意**字符串是不可变类型**，所以**不能通过索引运算修改字符串中的字符**
	- 遍历：同
	## 字符串的方法
	- 通过对象引用调用对象方法的语法，跟前面使用列表方法的语法是一样的
	- 大小写：
		```python
		s1 = 'hello, world!'
		# 字符串首字母大写
		print(s1.capitalize())  # Hello, world!
		# 字符串每个单词首字母大写
		print(s1.title())       # Hello, World!
		# 字符串变大写
		print(s1.upper())       # HELLO, WORLD!
		s2 = 'GOODBYE'
		# 字符串变小写
		print(s2.lower())       # goodbye
		# 检查s1和s2的值
		print(s1)               # hello, world
		print(s2)               # GOODBYE
		``` 
		- 由于字符串是不可变类型，使用字符串的方法对字符串进行操作会产生新的字符串，但是**原来变量的值并没有发生变化**。所以上面的代码中，当我们最后检查 `s1` 和 `s2` 两个变量的值时， `s1` 和 `s2` 的值并没有发生变化
	- 查找：find 和 index（返回索引）
		```python
		s = 'hello, world!'
		print(s.find('or'))      # 8
		print(s.find('or', 9))   # -1 ，指定从索引为9的位置开始查找
		print(s.find('of'))      # -1
		print(s.index('or'))     # 8
		print(s.index('or', 9))  # ValueError: substring not found
		``` 
		- `find` 方法找不到指定的字符串会返回 `-1` ， `index` 方法找不到指定的字符串会引发 `ValueError` 错误
	- 性质判断： `startswith` 、 `endswith` 、用 `is` 开头的方法判断字符串的特征
		```python
		s1 = 'hello, world!'
		print(s1.startswith('He'))   # False
		print(s1.startswith('hel'))  # True
		print(s1.endswith('!'))      # True
		s2 = 'abc123456'
		print(s2.isdigit())  # False  ，判断字符串是不是完全由数字构成
		print(s2.isalpha())  # False，判断字符串是不是完全由字母构成（不包括Emoji，指的是Unicode字符）
		print(s2.isalnum())  # True，判断字符串是不是由字母和数字构成
		```
	- 格式化： 通过 `center` 、 `ljust` 、 `rjust` 方法做居中、左对齐和右对齐的处理，使用 `zfill` 方法在字符串左边补零
		- f-string 的格式化：
		- ![[Pasted image 20250505091719.png]]
	- 修剪： `strip` 方法可以帮我们获得将原字符串修剪掉左右两端指定字符之后的字符串，默认是修剪空格字符
		```python
		s1 = '   jackfrued@126.com  '
		print(s1.strip())      # jackfrued@126.com，去掉两边的空格
		s2 = '~你好，世界~'
		print(s2.lstrip('~'))  # 你好，世界~
		print(s2.rstrip('~'))  # ~你好，世界
		``` 
	- 替换： `replace` 方法的第一个参数是被替换的内容，第二个参数是替换后的内容，还可以通过第三个参数指定替换的次数（默认是全部替换）
		```python
		s = 'hello, good world'
		print(s.replace('o', '@'))     # hell@, g@@d w@rld
		print(s.replace('o', '@', 1))  # hell@, good world
		```
	- 拆分与合并： `split` 方法将一个字符串拆分为多个字符串（放在一个列表中），也可以使用字符串的 `join` 方法将列表中的多个字符串连接成一个字符串
		```python
		s = 'I love you'
		words = s.split()
		print(words)            # ['I', 'love', 'you']
		print('~'.join(words))  # I~love~you
		# 还可以用其他字符来拆分字符串，并且可以指定最大拆分次数
		s = 'I#love#you#so#much'
		words = s.split('#')
		print(words)  # ['I', 'love', 'you', 'so', 'much']
		words = s.split('#', 2)
		print(words)  # ['I', 'love', 'you#so#much']
		``` 
	- 编码和解码：
		- 字节（bytes）表示二进制数据，字节串就是**由零个或多个字节组成的有限序列**
		- 通过字符串的 `encode` 方法，我们可以按照某种编码方式将字符串编码为字节串，我们也可以使用字节串的 `decode` 方法，将字节串解码为字符串
		```python
		a = '骆昊'
		b = a.encode('utf-8')
		c = a.encode('gbk')
		print(b)                  # b'\xe9\xaa\x86\xe6\x98\x8a'，这里b是二进制（binary）意思
		print(c)                  # b'\xc2\xe6\xea\xbb'
		print(b.decode('utf-8'))  # 骆昊
		print(c.decode('gbk'))    # 骆昊
	 	```  
- 10:05 
	#编程 #计算机科学
	# 字节
	
	- 1 字节（bytes）= 8 位二进制（bit）
		- 每个二进制位（bit）可以是 0 或 1，因此 1 字节可以表示 256 种不同值
	## 字符集  ^zifu
	-  ACSII（1 字节）：仅覆盖英文字母、数字、基础符号，范围 0~127（共 128 个字符）
	- Unicode（1~4 字节）：涵盖全球所有语言，给每个字符分配唯一的代码点
		- 代码点的数值是固定的，但 **如何存储这个数值** 需要编码方案来决定，这就产生了 UTF-8，UTF-16 以及 UTF-32（会以不同的规则将代码点转换为字节串，**字节串不同**）
		- 以汉字“中”为例，Unicode ‘中‘的代码点是 20013（十六进制就是 `U+4E2D` ），二进制形式是 `0100 1110 0010 1101` （共 16 位）
			- UTF-8：可变长度（1-4 字节，ASCII 字符只需 1 字节，拉丁/希腊字母需要 2 字节，常见汉字需要 3 字节，生僻字符需要 4 字节）
				- 对于 1 字节的字符，将最高位设为 0，其余 7 位设置为 Unicode 码点（向下兼容 ASCII 码）
				- 对于长度为 $n$ 字节的字符，将首个字节的高 $n$ 位都设置为 `1` ，第 $n+1$ 位设置为 `0` ；从第二个字节开始，每个字节的高 2 位都设置为 `10` （起到校验符作用，能够快速判断）；其余所有位用于填充字符的 Unicode 码点
				- 将 `0100 1110 0010 1101` 填入模板得到 `1110_0100|10_111000|10_101101` 十六进制就是 `0xE4 0xB8 0xAD`	即 0xE4B8AD （每个字节各自换成 16 进制）
			- UTF-16：固定或可变（2 或 4 字节），基本字符 2 字节，辅助平面 4 字节
				- ‘中’就直接是 `0x4E2D` 即 `01001110 00101101`
			- UTF-32：固定长度（4 字节）
				- ‘中’是 `0x00004E2D` 即 `00000000 00000000 01001110 00101101`
			- 从存储空间占用的角度看，使用 UTF-8 表示英文字符非常高效，因为它仅需 1 字节；使用 UTF-16 编码某些非英文字符（例如中文）会更加高效，因为它仅需 2 字节，而 UTF-8 可能需要 3 字节
		- 实际中经常用 **16 进制**来表示，因为二进制的话 1 字节需要 8 位，而 16 进制只需要 **2 位**就能对应 1 个字节（16\*\*2=256=2\*\*8）
		- 编码方式对比：
				 ![[Pasted image 20250505100319.png]]
	- GBK：汉字内码扩展规范，是 GB2312 的扩展，支持 21003 个汉字和 883 个符号，主要覆盖简体中文和部分繁体字。
		- 双字节（0x8140-0xFEFE），主要覆盖中文、日文、韩文字符，不兼容其他语言字符集，但因为无法处理少数民族文字或国际字符，逐渐被 UTF-8 取代
- 13:22 
	#编程 #python 
	# Python Day 12    数据结构——集合
	
	- 集合（set）：（数学定义）把一定范围的、确定的、可以区别的事物当作一个整体来看待，那么这个整体就是集合。特性是**无序性、互异性、确定性**
		- 集合不支持索引运算，不能有重复元素
		- 集合的**成员运算（in 和 not in）在性能上优于列表的成员运算**
			- ==因为集合底层使用了哈希存储（散列存储）==
	## 创建集合
	- 可以使用 `{}` 字面量语法， `{}` 中需要至少有一个元素，因为**没有元素的 `{}` 并不是空集合而是一个空字典**
	- set 构造器、集合生成式
		```python
		set1 = {1, 2, 3, 3, 3, 2}
		print(set1)  # {1,2,3}
	
		set2 = {'banana', 'pitaya', 'apple', 'apple', 'banana', 'grape'}
		print(set2) # {'apple','grape','banana','pitaya'}
	
		set3 = set('hello')
		print(set3)  # {'e','l','h','o'}
	
		set4 = set([1, 2, 2, 3, 3, 3, 2, 1]) #把列表转化为集合
		print(set4)  # {1,2,3}
		# 集合生成式
		set5 = {num for num in range(1, 20) if num % 3 == 0 or num % 7 == 0}
		print(set5) # {3,6,7,9,12,14,15,18}
		```
		- 集合中的元素必须是 `hashable` 类型（能计算出哈希码的数据类型）
			- 通常不可变类型都是 `hashable` 类型（如 int、float、bool、str、tuple）
			- 可变类型都不是 `hashable` 类型（如列表、集合），所以集合不能作为集合的元素，不存在嵌套集合
	## 元素遍历
	- 直接对集合元素用 for-in 循环遍历（不能用索引）
		```python
		set1 = {'Python', 'C++', 'Java', 'Kotlin', 'Swift'}
		for elem in set1:
	    	print(elem)  # 每次输出顺序都不一样
		```
	## 集合的运算
	- 成员运算：in 和 not in
	- 二元运算：交集、并集、差集、对称差
		```python
		set1 = {1, 2, 3, 4, 5, 6, 7}
		set2 = {2, 4, 6, 8, 10}
		# 交集
		print(set1 & set2)                      # {2, 4, 6}
		print(set1.intersection(set2))          # {2, 4, 6}
		# 并集
		print(set1 | set2)                  # {1, 2, 3, 4, 5, 6, 7, 8, 10}
		print(set1.union(set2))             # {1, 2, 3, 4, 5, 6, 7, 8, 10}
		# 差集
		print(set1 - set2)                      # {1, 3, 5, 7}
		print(set1.difference(set2))            # {1, 3, 5, 7}
		# 对称差
		print(set1 ^ set2)                      # {1, 3, 5, 7, 8, 10}
		print(set1.symmetric_difference(set2))  # {1, 3, 5, 7, 8, 10}	
		```
	- 比较运算（子集、真子集和超集）
		- \=\=，!=，<，>，<=，>=
		```python
		set1 = {1, 3, 5}
		set2 = {1, 2, 3, 4, 5}
		set3 = {5, 4, 3, 2, 1}
	
		print(set1 < set2)   # True
		print(set1 <= set2)  # True
		print(set2 < set3)   # False
		print(set2 <= set3)  # True
		print(set2 > set1)   # True
		print(set2 == set3)  # True
	
		print(set1.issubset(set2))    # True
		print(set2.issuperset(set1))  # True
		``` 
	## 集合的方法
	- 添加（add），删除（discard），清空（clear）
		```python
		set1 = {1, 10, 100}
		# 添加元素
		set1.add(1000)
		set1.add(10000)
		print(set1)  # {1, 100, 1000, 10, 10000}
		# 删除元素
		set1.discard(10)
		if 100 in set1:
	   		set1.remove(100)
		print(set1)  # {1, 1000, 10000}
	# 清空元素
		set1.clear()
		print(set1)  # 输出：set()
		```
		- 删除元素的 `remove` 方法在元素不存在时会引发 `KeyError` 错误，所以上面的代码中我们先通过成员运算判断元素是否在集合中。集合类型还有一个 `pop` 方法可以从集合中随机删除一个元素，该方法在删除元素的同时会返回（获得）被删除的元素，而 `remove` 和 `discard` 方法仅仅是删除元素，不会返回（获得）被删除的元素
	- 判断 2 个集合有无相同元素： `isdisjoint` 方法
		```python
		set1 = {'Java', 'Python', 'C++', 'Kotlin'}
		set2 = {'Kotlin', 'Swift', 'Java', 'Dart'}
		set3 = {'HTML', 'CSS', 'JavaScript'}
		print(set1.isdisjoint(set2))  # False  有相同元素返回false
		print(set1.isdisjoint(set3))  # True  没有相同元素返回ture
		```
	## 不可变集合
	- 名为 forzenset， `set` 跟 `frozenset` 的区别就如同 `list` 跟 `tuple` 的区别。它可以作为 `set` 中的元素，除了不能添加和删除元素， `frozenset` 在其他方面跟 `set` 是一样的
	```python
	fset1 = frozenset({1, 3, 5, 7})
	fset2 = frozenset(range(1, 6))
	print(fset1)          # frozenset({1, 3, 5, 7})
	print(fset2)          # frozenset({1, 2, 3, 4, 5})
	print(fset1 & fset2)  # frozenset({1, 3, 5})
	print(fset1 | fset2)  # frozenset({1, 2, 3, 4, 5, 7})
	print(fset1 - fset2)  # frozenset({7})
	print(fset1 < fset2)  # False
	``` 
- 21:39 
	#健身 #凯圣王训练营 
	# 一年级第二天：时间轴与身体结构筛查
	- 时间轴：
			![[Pasted image 20250505152730.png]]
		- ![[Pasted image 20250505152818.png]]
		- ![[Pasted image 20250505152842.png]]
	-  足背屈测试：脚尖对向墙面，间隔一拳加一指的距离（就是用手比个赞👍），在脚跟不离开地面情况下，膝盖向前顶：
		- 可以躯干后仰并触碰墙面为 100 分
		- 躯干挺直并触碰墙面为 90 分
		- 躯干需要弯曲（前倾）才能触碰地面为 80 分
		- 即使弯曲躯干也无法触碰墙面为不及格
		- ==我不及格==
	- 髋关节活动度测试：
		- 脚尖向外 45°，下蹲后膝盖无法与第二脚趾对齐，导致膝盖内（髋关节活动度差，大腿内收肌群紧张）
		- ==我还行==
	- 肩关节活动度测试：
		- 正常：躯干挺直且无肋骨外翻状态下，肩屈可过躯干约 25°
		- 不足：躯干挺直且无肋骨外翻状态下，肩屈无法超过躯干或平行躯干
			- 肩绕环测试：手握白蜡杆从身前绕道身后，双手距离越大肩关节活动度越差，距离越小活动度越好
		- ==我不足==（平行躯干）
	- 腘绳肌紧张程度测试：平躺在瑜伽垫上，将大腿抬至垂直地面（要钩住脚尖）
		- 保持大腿垂直地面，小腿与检测用的白蜡杆（垂直地面）角度大于 20°，即较为紧张
		- 保持大腿垂直地面，小腿与检测用的白蜡杆（垂直地面）角度小于 20°，表现较好
		- ==我较紧张==
	## 身体结构灵活度的失衡问题
	- 足背屈受限：蹲不下去、后脚跟抬起（增加膝关节压力）
	- 腘绳肌紧张：骨盆眨眼
	- 髋关节活动度受限：骨盆眨眼、膝盖内扣
	- 肩关节活动度受限：飞肘、无背刚性
	- 交叉综合症：
		- 骨盆前倾：腹直肌弱，臀部过于紧张
		- 骨盆后倾：腹直肌强，臀部弱
		- （上交叉综合征）圆肩驼背、肩胛骨外翻：（日常太多前倾动作）三角肌前束、胸大肌、胸小肌过于紧张
		- 初步解决思路：改善**肌力失衡**（放松紧张的肌肉，锻炼薄弱的肌肉）
	
	 