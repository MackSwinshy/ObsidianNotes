
- 09:59 
	#编程 #python 
	# Python Day 18     面向对象编程入门
	- 编程范式：程序设计的方法论
	- 在面向对象编程的世界里，程序中的**数据和操作数据的函数是一个逻辑上的整体**，我们称之为**对象**，**对象可以接收消息**，解决问题的方法就是**创建对象并向对象发出各种各样的消息**；通过消息传递，程序中的多个对象可以协同工作，这样就能构造出复杂的系统并解决现实中的问题
		- 消息指调用的方法名和参数，方法是具体实现
		- 消息不仅是数据，还包含行为指令，体现了 OOP 的封装特性（数据和方法绑定）
	## 类和对象
	- 面向对象编程本质是把一组数据和处理数据的方法组成**对象**，把行为相同的对象归纳为**类**，通过**封装**隐藏对象的内部细节，通过**继承**实现类的特化和泛化，通过**多态**实现基于对象类型的动态分派
		- 对象 object：是一个**具体**的概念
			- 在面向编程中，**一切皆为对象，是对象就有属性和行为**，而且**对象一定属于某个类**。对象的属性是静态特征，行为是动态特征
		- 类 class：是**抽象**的概念，把某些对象的共同特征抽取出来就是一个类
			- **对象是类的实例，是可以接收消息/操作的实体，类是对象的蓝图和模板**
	## 定义类
	- 用 `class` 关键字加上类名来定义类，类中的函数是对一类对象共同的*动态*特征的提取，这些函数通常称为**方法**，方法就是对象的行为，也就是对象可以接收的消息（被操作？）
	- 方法的第一个参数通常都是 `self` ，它代表了接收这个消息的对象本身
	```python
	class Student:
	    def study(self, course_name):
	        print(f'学生正在学习{course_name}.')
	    def play(self):
	        print(f'学生正在玩游戏.')
	```
	## 创建和使用对象
	- 可以用构造器语法来创建对象
		```python
		stu1 = Student()   # 构造器语法
		stu2 = Student()
		print(stu1) # 输出对象在内存中的地址，<__main__.Student object at 0x10ad5ac50>
		print(stu2)    # <__main__.Student object at 0x10ad5acd0> 
		print(hex(id(stu1)), hex(id(stu2)))    # 0x10ad5ac50 0x10ad5acd0
		``` 
		- 构造器语法：在类的名字后跟上圆括号
		- 定义的变量/对象其实保存的是==一个对象在内存中的逻辑地址==（而不是某个值），所以 `stu3 = stu2` ==这样的赋值语句并没有创建新的对象，只是用一个新的变量保存了已有对象的地址==（stu2 还是原来的地址，stu3 与 stu2 相同）
	- 给对象发消息/调用对象的方法
		```python
		# 通过“类.方法”调用方法
		# 第一个参数是接收消息的对象
		# 第二个参数是学习的课程名称
		Student.study(stu1, 'Python程序设计')    # 学生正在学习Python程序设计.
		# 通过“对象.方法”调用方法
		# 点前面的对象就是接收消息的对象
		# 只需要传入第二个参数课程名称
		stu1.study('Python程序设计')             # 学生正在学习Python程序设计.
		Student.play(stu2)                      # 学生正在玩游戏.
		stu2.play()                             # 学生正在玩游戏.
		``` 
		- `self` 指向**对象实例的内存地址**，通过 `self` 可以访问和修改对象的属性和方法
		- 通过 `对象.方法()` 调用时，Python 会**自动将对象实例作为 `self` 参数传入**，无需手动传递
	## 初始化方法
	- 给对象定义属性（之前讲的都是对象的行为）用名为 `__init__` 的方法（初始化方法）
		- 在我们调用 `Student` 类的构造器创建对象时，首先会在内存中获得保存学生对象所需的内存空间，然后通过自动执行 `__init__` 方法，完成对内存的初始化操作，也就是把数据放到内存空间中
	```python
	class Student:
	    """学生"""
	    def __init__(self, name, age):
	        """初始化方法"""
	        self.name = name  # 直接定义属性，不用提前声明（动态语言特性）
	        self.age = age
	    def study(self, course_name):
	        """学习"""
	        print(f'{self.name}正在学习{course_name}.')
	    def play(self):
	        """玩耍"""
	        print(f'{self.name}正在玩游戏.')
	        
	# 调用Student类的构造器创建对象并传入初始化参数
	stu1 = Student('骆昊', 44)
	stu2 = Student('王大锤', 25)
	stu1.study('Python程序设计')    # 骆昊正在学习Python程序设计.
	stu2.play()                    # 王大锤正在玩游戏.
	``` 
	## 面向对象的支柱
	- 封装 encapsulation：**隐藏一切可以隐藏的实现细节，只向外界暴露简单的调用接口**
	- 继承 inheritance
	- 多态 polymorphism
	## 面向对象案例
	1. 时钟：要求定义一个类描述数字时钟，提供走字和显示时间的功能
	```python
	import time
	# 定义时钟类
	class Clock:
	    """数字时钟"""
	    def __init__(self, hour=0, minute=0, second=0):
	        self.hour = hour
	        self.min = minute
	        self.sec = second
	    def run(self):
	        """走字"""
	        self.sec += 1
	        if self.sec == 60:
	            self.sec = 0
	            self.min += 1
	            if self.min == 60:
	                self.min = 0
	                self.hour += 1
	                if self.hour == 24:
	                    self.hour = 0
	    def show(self):
	        """显示时间"""
	        return f'{self.hour:0>2d}:{self.min:0>2d}:{self.sec:0>2d}'
	# 创建时钟对象
	clock = Clock(23, 59, 58)
	while True:
	    # 给时钟对象发消息读取时间
	    print(clock.show())
	    # 休眠1秒钟
	    time.sleep(1)
	    # 给时钟对象发消息使其走字
	    clock.run()
	```
	2. 平面上的点：要求定义一个类描述平面上的点，提供计算到另一个点距离的方法
	```python
	class Point:
	    """平面上的点"""
	    def __init__(self, x=0, y=0):
	        self.x, self.y = x, y
	    def distance_to(self, other):
	        """计算与另一个点的距离
	        :param other: 另一个点
	        """
	        dx = self.x - other.x
	        dy = self.y - other.y
	        return (dx * dx + dy * dy) ** 0.5
	    def __str__(self):
	        return f'({self.x}, {self.y})'
	p1 = Point(3, 5)
	p2 = Point(6, 9)
	print(p1)  # 调用对象的__str__魔法方法
	print(p2)
	print(p1.distance_to(p2))
	```
	- `__str__` 用于定义对象的**字符串表示**（用户友好，不然直接 print 只会输出内存地址），这样当使用 `print(obj)` 或 `str(obj)` 时自动调用`__str__`
- 10:12 
	#编程 
	# 魔法方法
	- 是用于定义**类**的特定行为
	- 核心作用是让开发者自定义类与 Python 内置功能（如运算符、迭代、上下文管理）的交互方式
	- 常用魔法方法：
		- `__init__(self)` ：对象初始化时调用
		- `__str__(self)` ：定义对象的字符串表示（ `print()` 时自动调用）
		- `__add__(self,other)` ：重载 `+` 运算符
	
	# 内置属性/元信息 Built-in Attributes
	- 内置属性大多数都直接保存在对象的**结构体（C 语言层面）** 中
	- 访问对象的某个属性时先在C 结构体中查找该属性，若属性是内置的，会通过描述符协议（如 `__get__` 方法）返回值；若未找到，再检查对象的 `__dict__`（用于动态添加的自定义属性）
	- 函数属性
		- 在函数定义时就已经由解释器自动填充
		- 常用属性：
			- `__name__` ：函数名称（字符串）
			- `__doc__` ：函数的文档字符串（即 `"""docstring"""` ）
			- `__defaults__` ： 包含函数默认参数值的元组（若无默认参数则为 `None` ）
			- `__annotations__` ： 函数的参数/返回值类型注解（字典形式，如 `{'x': int, 'return': str}` ）
	- 模块/文件属性（对应一个 `.py` 文件）
		- 在模块加载时由解释器动态生成
		- 常用属性：
			- `__name__` ：模块名称。若模块是主程序，则为 `__main__` ；若被导入，则为模块文件名
			- `__file__` ：模块文件的绝对路径（字符串）
			- `__doc__` ：模块的文档字符串（文件顶部的 `"""docstring"""` ）
			- `__package__` ： 模块所属的包名（若模块在包中） 
- 10:59 
	#编程 #python 
	# Python Day 19    面向对象编程进阶
	## 可见性和属性装饰器
	- 对象的属性通常会被设置为私有（private）或受保护（protected）的成员（不允许直接访问属性）
	- 对象的方法通常都是公开的（public），因为公开的方法是对象能够接受的消息，也是对象暴露给外界的调用接口（访问可见性）
	- 通过给对象属性名添加前缀下划线的方式来说明属性的访问可见性
		-  `__name` 表示一个私有属性， `_name` 表示一个受保护属性
		```python
		class Student:
	    	def __init__(self, name, age):
	        	self.__name = name
	        	self.__age = age
	    	def study(self, course_name):
	        	print(f'{self.__name}正在学习{course_name}.')
		stu = Student('王大锤', 20)
		stu.study('Python程序设计')
		print(stu.__name)  # AttributeError: 'Student' object has no attribute '__name'
		``` 
		- 以 `__` 开头的属性 `__name` 相当于是私有的，在类的外面无法直接访问，但是类里面的 `study` 方法中可以通过 `self.__name` 访问该属性
		- （python 没有做出严格限制）实在想访问，可以用 `stu._Student__name` 的方式访问受保护成员
	## 动态属性
	- 动态语言：（Wiki）在运行时可以改变其结构的语言，例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化
		```python
		class Student:
	    	def __init__(self, name, age):
	        	self.name = name
	        	self.age = age
		stu = Student('王大锤', 20)
		stu.sex = '男'  # 给学生对象动态添加sex属性
		``` 
	- 如果不希望在使用对象时动态的为对象添加属性，可以使用 Python 语言中的 `__slots__` 魔法
		```python
		class Student:
	    	__slots__ = ('name', 'age')
	    	def __init__(self, name, age):
	       		self.name = name
	        	self.age = age
		stu = Student('王大锤', 20)
		# AttributeError: 'Student' object has no attribute 'sex'
		stu.sex = '男'
		```
	## 静态方法和类方法
	- 二者都是发给类的消息，无本质区别
		- 操作上的区别在于类方法的第一个参数是类对象本身 `cls` ，而静态方法则没有这个参数
		- **对象方法、类方法、静态方法都可以通过“类名.方法名”的方式来调用，区别在于方法的第一个参数到底是普通对象 `self` 还是类对象 `cls` ，还是没有接受消息的对象**
		```python
		class Triangle(object):
	    """三角形"""
	    	def __init__(self, a, b, c):
	        	"""初始化方法"""
	        	self.a = a
	        	self.b = b
	        	self.c = c
	   		@staticmethod     # 静态方法
	    	def is_valid(a, b, c):
	        	"""判断三条边长能否构成三角形(静态方法)"""
	        	return a + b > c and b + c > a and a + c > b
	    	# @classmethod       类方法
	    	# def is_valid(cls, a, b, c):    需要cls类对象
	    	#     """判断三条边长能否构成三角形(类方法)"""
	    	#     return a + b > c and b + c > a and a + c > b
	    	def perimeter(self):
	        	"""计算周长"""
	        	return self.a + self.b + self.c
	    	def area(self):
	        	"""计算面积"""
	        	p = self.perimeter() / 2
	        	return (p * (p - self.a) * (p - self.b) * (p - self.c)) ** 0.5
		```
		- 给 Triangle类发送的消息：判断三边能够构造三角形（如果是给 triangle对象，你都创造出这个对象了，言下之意就是三条边能构成三角形。所以希望是在创造对象前就判断能否构成，既然此时还未创造对象，这肯定就不是给对象的消息）
		- `property` 装饰器（python 内置）：让方法返回值变成属性（优点：不用再通过调用方法的方式来访问，而是用对象访问属性的方式直接获得）
		```python
	    	@property
	    	def perimeter(self):
	        	"""计算周长"""
	        	return self.a + self.b + self.c
			@property
	    	def area(self):
	        	"""计算面积"""
	        	p = self.perimeter / 2
	        	return (p * (p - self.a) * (p - self.b) * (p - self.c)) ** 0.5
			t = Triangle(3, 4, 5)
		print(f'周长: {t.perimeter}')  # perimeter和area变成属性，可以直接访问
		print(f'面积: {t.area}')
		``` 
	## 继承和多态
	- python 支持在已有类的基础上创建新类，从而减少重复代码的编写
	-  提供继承信息的类叫做父类（超类、基类），得到继承信息的类叫做子类（派生类、衍生类）
		```python
		class Person:
	    	"""人"""
	    	def __init__(self, name, age):
	        	self.name = name
	        	self.age = age
	    	def eat(self):
	        	print(f'{self.name}正在吃饭.')
	    	def sleep(self):
	        	print(f'{self.name}正在睡觉.')
	        	
		class Student(Person):   # 继承语法
	    	"""学生"""
	    	def __init__(self, name, age):
	        	super().__init__(name, age)
	    	def study(self, course_name):
	        	print(f'{self.name}正在学习{course_name}.')
	
		class Teacher(Person):
	    	"""老师"""
	    	def __init__(self, name, age, title):
	        	super().__init__(name, age)
	        	self.title = title
	    	def teach(self, course_name):
	        	print(f'{self.name}{self.title}正在讲授{course_name}.')
		stu1 = Student('白元芳', 21)
		stu2 = Student('狄仁杰', 22)
		tea1 = Teacher('武则天', 35, '副教授')
		stu1.eat()
		stu2.sleep()
		tea1.eat()
		stu1.study('Python程序设计')
		tea1.teach('Python程序设计')
		stu2.study('数据科学导论')
		```
		 - 继承的语法是在定义类的时候，在类名后的圆括号中指定当前类的父类
		 - 在子类的初始化方法中，可以通过 `super().__init__()` 来调用父类初始化方法
			 - `super` 函数是 Python 内置函数中专门为获取当前对象的父类对象而设计的
		 - 里氏替换原则（Liskov Substitution Principle）：在实际开发中，经常会用子类对象去替换掉一个父类对象
- 11:38 
	#编程 #python 
	# 私有属性
	- 实现原理：**名称修饰** Name Mangling，当属性/方法以 `__` 开头时，解释器对名称进行自动改写
		- 例如类 `MyClass` 中的 `__private_attr` 会被重命名为 `_MyClass__private_attr` 
		-  外部无法直接访问也是因为名称被改写：在类外部尝试访问 `obj.__private_attr` 会失败，因为实际名称已变为 `_MyClass__private_attr` （==当然你按照后者形式还是可以访问私有属性的==）
		- python 没有严格的访问控制，并不是真正的私有
	- 受保护成员：单下滑线 `_` 前缀（如 `_protected_attr` ），Python 不会对单下划线前缀的成员进行任何特殊处理，访问不会报错，但违反约定可能导致意外行为
- 15:15 
	#健身 #凯圣王训练营 
	# 一年级第 5 天      动作日
	## 动作结构
	1. 卧推典型错误：
		-  仰头（颈伸）：颈椎形成反弓   ←  正确：收着下巴卧推
		- 耸肩：胸部本来就有把肩带拉下的功能，耸肩可能肩关节受伤；还有限制胸肌发展（拉长胸肌纤维）  
			- 造成原因：斜方肌紧张，前锯肌无力
		- 肩前旋：（底端时肩膀被撬起来）肩容易受伤
			- 原因：胸小肌紧张，发力模式不正确
		- 开肘：在底部时肘部移动，造成大臂与驱赶垂直，伤肩
	2. 硬拉典型错误：
		- 髋膝联动不协调：先伸膝再伸髋，伤腰
		- 弓背：
		- 骨盆前倾顶腰：伸髋锁定时超了，腰部有剪切力
	3. 深蹲典型错误：
		- 膝超伸：伸膝时不是膝盖在从前往后撞，要有控制
		- 膝盖内扣：膝盖应该跟大脚趾/二脚趾一样朝向
		- 重心前移：后侧链太紧张，膝/腰压力大
		- 飞肘：（低杠位无所谓）高杠位飞肘会让肩胛打开，上背部失去刚性，伤腰
		- 足背屈受限： ←后面踩个片
		- 骨盆眨眼：腘绳肌紧张，核心没有力量 
- 15:39 
	#健身 #凯圣王训练营 
	# 一年级第 6 天              口味降级、基本功、卧推        
	## 饮食结构
	- 口味降级开始≠断崖式    （干净：添加物少）
		- 饮食更好计算、碳蛋脂数据更清晰
	- 减脂控制血糖波动：GI 值、GL 值
		- ==吃饭顺序：蔬菜→肉类→主食==（膳食纤维先进入肠胃，减慢原本容易消化吸收的碳水/高 GI 食物的转化血糖速度）
	## 身体结构
	- 基本功/稳定性训练增加的重要性：各种关节活动度、稳定性改善
	- 训练/健身就是身体的开发过程，开发关节的活动度、刚性、身体的联动性、肌肉的控制能力、募集感觉、力量、耐力、速度
	## 动作结构
	- 卧推发力感：主要是==水平内收抗阻==（而不是伸肘屈肘），想的是==大臂向里收紧==（而不是把杠铃推上去） 
- 15:44 
	#健身 #动作结构
	# 史密斯上斜卧推
	参考网址： [史密斯上斜卧推](https://www.bilibili.com/video/BV1o8bwewEyT/?spm_id_from=333.1387.search.video_card.click&vd_source=85050722c3bd101265950cd0862f2dd9)
	- 座椅：与地面倾斜角 45°左右，凳子调节两端（坐垫与靠背）接近 135 °
		- 全程屁股不能离开凳子，脚后跟踩死地面
	- 上胸发展不好可能原因：
		1.  平常推平板时胸椎弧度不好，更接近下斜
		2.  动作没有顶峰收缩，肌肉没有好的挤压感（影响乳酸阈值、代谢压力）
	- 握距： 小臂垂直地面
		- 杠铃落点应该在肩膀处/锁骨，减少肩屈行程/肩部发力
	- 沉肩细究：
		- 不要极端往上顶胸椎，不然会更像平板。保证肩胛能释放出正常功能即可
		- 如果过分沉肩，肩膀压力变大←肩锁关节太低（大臂处于外展状态，胸锁关节要释放活动度）
		- 把沉肩理解为**不要过度耸肩**即可 （肩胛能处于上回旋状态，同时上斜方肌不要收紧）
		- **不需要刻意沉肩、内收肩胛**
	- 全程收紧下巴：减小颈椎压力
	- 最低落点位置：取决于最低点时你的肩不能旋前（不能被翘起来 ←活动度有问题）（对于身体结果不够好的建议触点往上 10~15 cm）
	- 想象的是大臂向里收紧（主要是水平外展阻力），不是杠铃往上推
	- 呼吸：采用胸式呼吸，但不要顶满（此时失去胸廓弹性）