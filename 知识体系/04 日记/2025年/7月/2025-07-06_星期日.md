---
tags:
  - Daily-note
创建时间: 2025/07/06 09:20
上次编辑时间: 2025/09/04 10:52
年度: "2025"
月份: "07"
周期: "星期日"
---
## Thino 笔记
- 11:15 
	#编程/算法 
	# 基础数据类型的存储
	## 整数
	- 原码：数字二进制的最高位视为符号位（0 表示正数，1 表示负数）。其余位表示数字的值
	- 反码（1‘s Complement）：正数的反码与其原码相同，负数的反码是对其原码**除符号位外**的所有位取反
	- **补码**（Two's Complement）：正数的补码与其相同，负数的补码是在其反码的基础上加 1
	    - 意义
			1. 统一加减法：用加法器就能完成减法运算 （本质是**同余计算**）
			2. 表示范围对称且高效： $-2^{n-1}$ 到 $2^{n-1}-1$ （ $n$ 为位数 ）
			3. 零的唯一性
		- 具体实现（以 1 字节为例）：
			1. 原码与反码的和是 `1111_1111` （每位取反），则原码与补码的和为 `1_0000_0000` 等同于 `0000_0000` （只有 8 位） ，利用同余计算的知识： $b+b_{comp}\equiv 0\pmod {2^8}$ ，则有$$
	a-b\equiv a+b_{comp}\pmod {2^8}
	$$
			2. 从补码得到原码有 2 种方式，一是逆运算（先减 1 后取反），二是求补码的补码（先取反后加 1，因为原码和补码的和是 `0000_0000` ，则补码与补码的补码之和也是 `0000_0000` ），我们能注意到 $[-127,127]$ 的整数都有对应的原码、反码、补码，但补码 `1000_0000` 是例外，其原码（按照常规方法）是 `0000_0000` 矛盾，所以我们规定其代表 $-128$ ，并且 $(-1)+(-127)$ 在补码的计算结果下就是 $-128$ （ `1000_0001` + `1111_1111` = `1000_0000` ）
			3. $+0$ 和 $-0$ 的补码都是 `0000_0000`
	## 浮点数
	- 浮点数的储存（根据 IEEE 754 标准）由 3 个部分组成（以 `float` 为例，占 4 字节 $b_{31}b_{30}b_{29} ...b_2b_1b_0$ ）
		- 符号位 $\mathbf S$ ：占 1 位，对应 $b_{31}$
		- 指数位 $\mathbf E$ ：占 8 位，对应 $b_{30}b_{29}...b_{23}$ 
		- 分数位 $\mathbf N$ ：占 23 位，对应 $b_{22}b_{21}...b_0$
		- 二进制数对应的计算方式为：（-127 是为了表示负数幂，并且对称，小数点前为 1 是科学表达式的结果） $$
	val=(-1)^{b_{31}}\times 2^{(b_{30}b_{29}...b_{23})_2-127}\times (1.b_{22}b_{21}...b_0)_2
	$$
			- 转换到十进制下即为： $val=(-1)^{\mathbf S}\times 2^{\mathbf E-127}\times (1+\mathbf N)$
			- 其中指数位全为 0 或全为 1 对应有特殊值（0，无穷大，次正规数，NaN）
			![[Pasted image 20250706104825.png]]
			![[Pasted image 20250706105500.png]] 
	## 字符
	- 详见 [[05  周一#^zifu]]
	- **编程语言中的字符编码**：
		- 对于以往的大多数编程语言，程序运行中的字符串都采用 UTF-16 或 UTF-32 这类等长编码（如 JAVA，C#，JavaScript 等）
			- 意义：这样做能够**将字符串看作数组来处理**（UTF-8 是可变字节，每个字符的长度都可能不同），进行随机访问、字符计数、字符串操作等都非常简单
			- Python 的 `str` 使用 Unicode 编码，并采用灵活的字符串表示（存储的字符长度取决于字符串中最大的 Unicode 码点）

- 11:40 
	#编程/算法 
	# 列表 list
	- 列表是一个抽象的数据结构概念，它表示元素的有序集合，无须使用者考虑容量限制的问题（数组是固定容量）
	- 具体实现：许多语言中的标准库提供的列表是基于**动态数组**实现的（下以 Python 为例）

- 11:53 
	#编程/算法 
	# 列表 list
	- 列表是一个抽象的数据结构概念，它表示元素的有序集合，无须使用者考虑容量限制的问题（数组是固定容量）
	- 具体实现：许多语言中的标准库提供的列表是基于**动态数组**实现的（下以 Python 为例）
		- 初始容量：选取一个合理的数组初始容量
		- 成员数量记录：声明一个变量 `size` ，用于记录列表当前元素数量，并随着元素插入和删除实时更新（可以定位列表尾部），判断是否需要扩容
		- 扩容机制：（当成员数量与容量相同时触发扩容）根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组
	```python
	# 简化的列表类实现
	class MyList:
	    """列表类"""
	    def __init__(self):
	        """构造方法"""
	        self._capacity: int = 10  # 列表容量
	        self._arr: list[int] = [0] * self._capacity  # 数组（存储列表元素）
	        self._size: int = 0  # 列表长度（当前元素数量）
	        self._extend_ratio: int = 2  # 每次列表扩容的倍数
	
	    def size(self) -> int:
	        """获取列表长度（当前元素数量）"""
	        return self._size
	
	    def capacity(self) -> int:
	        """获取列表容量"""
	        return self._capacity
	
	    def get(self, index: int) -> int:
	        """访问元素"""
	        # 索引如果越界，则抛出异常，下同
	        if index < 0 or index >= self._size:
	            raise IndexError("索引越界")
	        return self._arr[index]
	
	    def set(self, num: int, index: int):
	        """更新元素"""
	        if index < 0 or index >= self._size:
	            raise IndexError("索引越界")
	        self._arr[index] = num
	
	    def add(self, num: int):
	        """在尾部添加元素"""
	        # 元素数量超出容量时，触发扩容机制
	        if self.size() == self.capacity():
	            self.extend_capacity()
	        self._arr[self._size] = num
	        self._size += 1
	
	    def insert(self, num: int, index: int):
	        """在中间插入元素"""
	        if index < 0 or index >= self._size:
	            raise IndexError("索引越界")
	        # 元素数量超出容量时，触发扩容机制
	        if self._size == self.capacity():
	            self.extend_capacity()
	        # 将索引 index 以及之后的元素都向后移动一位
	        for j in range(self._size - 1, index - 1, -1):
	            self._arr[j + 1] = self._arr[j]
	        self._arr[index] = num
	        # 更新元素数量
	        self._size += 1
	
	    def remove(self, index: int) -> int:
	        """删除元素"""
	        if index < 0 or index >= self._size:
	            raise IndexError("索引越界")
	        num = self._arr[index]
	        # 将索引 index 之后的元素都向前移动一位
	        for j in range(index, self._size - 1):
	            self._arr[j] = self._arr[j + 1]
	        # 更新元素数量
	        self._size -= 1
	        # 返回被删除的元素
	        return num
	
	    def extend_capacity(self):
	        """列表扩容"""
	        # 新建一个长度为原数组 _extend_ratio 倍的新数组，并将原数组复制到新数组
	        self._arr = self._arr + [0] * self.capacity() * (self._extend_ratio - 1)
	        # 更新列表容量
	        self._capacity = len(self._arr)
	
	    def to_array(self) -> list[int]:
	        """返回有效长度的列表"""
	        return self._arr[: self._size]
	```
	
	- Python 的列表 `list` 能够储存不同类型的成员（正常情况下，数组要求元素类型都一致）
		- 数组能够快速访问随机元素是因为元素的**储存字节长度是相同的**（不同类型肯定会不一样）
		![[Pasted image 20250706115121.png]] 
		- Python 中 `list` 实际存储的是==对象的引用/指针==（等于是**对象的指针在栈区内的存储是连续的，而需要通过指针访问的值在堆区的存储是分散的**），而每个指针的长度都是相同的（8 字节），再通过指针来访问存储在堆内存中的对象本身 
- 12:15 
	#编程 
	# 计算机的存储设备
	- 计算机中包括 3 种类型的存储设备：硬盘 （hard disk/hard drive）、内存（random-access memory, RAM）、缓存（cache memory）
		1. 缓存：存储经常访问的数据和指令，减少 CPU 访问内存的次数
		2. 内存：**临时存储当前运行的程序和正在处理的数据**
			- 英文 random-access 的由来是因它能随时从任何一个指定的地址写入（存入）或读出（取出）信息
		3. 硬盘： 长期存储数据，包括操作系统、程序、文件等
	- 在程序运行时，数据会从硬盘中被读取到内存中，供 CPU 计算使用。缓存可以看作 CPU 的一部分，**它通过智能地从内存加载数据**，给 CPU 提供高速的数据读取，从而显著提升程序的执行效率，减少对较慢的内存的依赖
		![[Pasted image 20250904101431.png]]
	- 数据结构的缓存效率：
		- 缓存未命中（cache miss）： CPU 尝试访问的数据不在缓存中，此时 CPU 不得不从速度较慢的内存中加载所需数据
			- 将 CPU 从缓存中成功获取数据的比例称为缓存命中率（cache hit rate），这个指标通常用来衡量缓存效率（命中率越高 CPU 读写数据效率越高）
		- 为达到更高的效率，缓存采取的数据加载机制：
			1. 缓存行： 不是单个字节地存储与加载数据，而是以缓存行为单位
			2. 预取机制：处理器会尝试预测数据访问模式，并根据特定模式将数据加载至缓存之中
			3. 空间局部性：如果一个数据被访问，那么它附近的数据可能近期也会被访问。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率
			4. 时间局部性：如果一个数据被访问，那么它在不久的将来很可能再次被访问。缓存利用这一原理，通过保留最近访问过的数据来提高命中率
		 - **数组具有更高的缓存命中率，因此它在操作效率上通常优于链表**（高缓存效率并不意味着数组在所有情况下都优于链表，尤其是数据量非常大、动态性很高、栈的预期大小难以估计的情景）
	- 数据结构的内存效率：
		 - **内存是有限的，且同一块内存不能被多个程序共享**
		 - **随着反复申请与释放内存，空闲内存的碎片化程度会越来越高**