---
tags:
  - Daily-note
创建时间: 2025/07/06 09:20
上次编辑时间: 2025/07/06 09:27
年度: "2025"
月份: "07"
周期: "星期一"
---
## Thino 笔记
- 19:55 
	#编程/数据库  #python 
	# Python Day 36 —— 关系型数据库和 MySQL 概述
	## 数据库发展史
	- 文件系统 $\to$ 网状数据库 & 层次数据库 $\to$ 关系数据库 $\to$ NoSQL 数据库 $\to$ NewSQL 数据库
		- 网状/层次数据库的不足：程序/数据与物理存储**强耦合**（改变存储位置会影响相关数据），数据结构复杂（尤其树形、网状在数据量大时）
			- 外在表现就是当用户需要读取某个数据时，需要知道（物理）存储的逻辑才能按照从属关系编码查找，例如获取某课的学生，需按“学校→系→课程→学生”的层级，这在数据量大时不可能
		- 关系数据库的创新：
			1. 将数据的逻辑关系与物理存储地址**解耦**： 通过三层模式架构（View→Logical Schema→Physical Schema），用存储引擎来管理磁盘布局。本质是操作时用**全局唯一逻辑标识（如表名+主键）代替物理地址，再由存储引擎动态映射到当前的物理地址**
			2. 数据组织呈现**二维表**：与“树/网状+物理指针”（基于图论，数据间存在显式的父子关系）不同，关系数据库的数据以二维表形式呈现（基于集合论，表是元组的集合，不像前者那样是每个“元组“是分散的）
			3. 操作简化：不再需要从根记录遍历指针链寻找目标，能直接通过任意行列组合访问；并且实现了二维**表与表之间的独立**（通过逻辑外键来关联，无需物理指针的绑定）
		- NoSQL、NewSQL（了解）：NoSQL 是为解决数据量的急剧增大、多结构化数据的存储、高并发读写等问题（分布式数据库）；NewSQL 是为在 NoSQL 基础上保留事务处理与 SQL 的能力
	## 关系代数
	关系代数是关系数据库的理论基础
	1. 基础概念
		-  关系 Relation：**一组元组的集合**（在数据库中呈现为一个二维表）
			- 组成要素：元组（行/记录）、属性（列/字段）、域（属性的取值范围）
			- 理解：符合逻辑的思考是初步发展的数据库（网状、层次）只有分散的不同个体的记录（即元组，因为确定记录的个体属性数目都已经确定了），在关系数据库中才把这些相似的元组聚集在一起看作一个集合来处理
		- 关系模式 Relation Schema：描述关系结构的数学语言
			- $R=[A_1,A_2,...,A_n]$ ， $R$ 是关系， $A_i$ 是属性， $A$ 是属性组（表示一个或多个属性 $A_i$ ）
			- $t \in R$ 表示 $t$ 是 $R$ 的一个元组， $t[A_i]$ 表示元组 $t$ 的单个 $A_i$ 属性分量， $t[A]$ 表示元组 $t$ 的属性组 $A$ 的多个分量集合
			- $t_r \in R$ ， $t_s \in S$ ， $\widehat {t_rt_s}$ ：表示元组的连接（新元组的属性数是 $R,S$ 关系的属性之和）
			- 给定关系 $R(X,Y)$ ，其中 $X,Y$ 都代表属性组（有一个或多个属性），则 $Y_X$ 表示**象集**，理解为：满足 $t[X]=x$ 的元组的所对应的 $Y$ **属性组的值的集合** $$
	Y_X=\{t[Y]\mid t \in R,t[X]=x\}
	$$
	2. 集合运算
		- 并运算 Union： $R \cup S$ ，合并 2 个关系中的所有元组，会去除重复的元组（要求 2 个关系必须并相容，即有相同数量的属性，且对应的属性域都相同）
		- 差运算 Difference： $R-S$ ，得到在 R 中但不在 S 中的元组（要求与上同）
		- 交运算 Intersection： $R \cap S$ ，得到同时属于 $R,S$ 的元组（要求与上同）
		- 笛卡尔积 Cartesian Product： $R \times S$ ，得到将 2 个关系的所有元组两两组合后的新关系（列数是 $R,S$ 之和，元组数是 $R,S$ 之积 ）
	3. 关系运算
		-  选择 Selection： $\sigma_p(R)$ ，从关系中选取满足条件 $p$ 的元组
		-  投影 Projection： $\pi_A(R)$ ，从关系中选择属性组 $A$ 来组成新的关系
		- 连接 Join： $R \bowtie_{A\,\theta\,B} S=\{\widehat{t_rt_s}\mid t_r\in R\land t_s\in S\land t_r[A]\,\theta\,t_s[B]\}$ ，从 $R,S$ 2 个关系的笛卡尔积中得到属性组的值满足目标比较关系的元组（ $A,B$ 是属性组， $\theta$ 是比较运算符 ）
			1.  等值连接： $\theta$ 是 $=$ 等号的连接运算 
			2. 自然连接：特殊的等值连接，要求进行比较的分量必须是相同的属性组，并且结果中会把去除重复属性列
			3. 外连接：⟗，在自然连接的基础上，保留连接失败的原关系中的特有元组（就是属性组值在另一关系中没有相同的元组），另一关系中的属性值（也就是原元组没有的属性）用 NULL 代替 
				- ⟕，左外连接：保留式子中左边关系的特有元组
				- ⟖，右外连接：保留式子中右边关系的特有元组
			4. 半连接： 仅返回左/右关系中满足连接条件的元组，且结果不包含另一关系的属性列
				- ⋉，左半连接：返回左关系...
				- ⋊，右半连接：返回右关系...
	4. **除运算**Division：给定关系 $R(X,Y)$ 和 $S(Y,Z)$ ，其中 $X,Y,Z$ 是属性组， $R$ 中的 $Y$ 与 $S$ 中的 $Y$ 可以有不同的属性名，但必须有相同的域，则除运算的定义为 $$
	R \div S=\{t_r[X]=x\mid t_r\in R \land \pi_Y(S)\subseteq Y_x\}
	$$ 得到的是一个新关系 $P(X)$ ，是 $R$ 中满足特定条件的元组在 $X$ 属性列上的投影（相当于新表格的列只有 $X$ 属性，行只有那些满足了条件的元组的值 $x$ ）；
	- 特定条件的理解：目标对象是 $R$ 中的元组， $\pi_Y(S)$ 是 $S$ 在 $Y$ 属性组的投影，这个是**确定**的（只与 $S$ 关系有关，并且这种投影会去重 ）； $R$ 关系在 $X$ 属性组上会有许多分量值 $x_1,x_2,...,x_n$ ，对每个分量值都做同样的操作——找对应的象集 $Y_{x_i}$ 然后判断 $Y_{x_i}$ 是否包含 $\pi_Y(S)$ ，如果包含就保留 $x_i$ （新表格中就会增加 $x_i$ 这一行 ）
	- 常见形式 $RS\div S$ 的意义（ $R,S$ 中的属性组不同 ）：就是在 $R,S$ 的联系 $RS$ 中，找出与 $S$ 中**所有**的元组有关系的 $R$ 元组